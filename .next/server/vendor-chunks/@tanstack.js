"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFiltering),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   RowExpanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowExpanding),\n/* harmony export */   RowPagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPagination),\n/* harmony export */   RowPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   RowSorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__._getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n   * react-table\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ \n\n\n//\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */ function flexRender(Comp, props) {\n    return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n    return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n    return typeof component === \"function\" && (()=>{\n        const proto = Object.getPrototypeOf(component);\n        return proto.prototype && proto.prototype.isReactComponent;\n    })();\n}\nfunction isExoticComponent(component) {\n    return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n        \"react.memo\",\n        \"react.forward_ref\"\n    ].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n    // Compose in the generic options to the user options\n    const resolvedOptions = {\n        state: {},\n        // Dummy state\n        onStateChange: ()=>{},\n        // noop\n        renderFallbackValue: null,\n        ...options\n    };\n    // Create a new table and store it in state\n    const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n        }));\n    // By default, manage table state here using the table's initial state\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>tableRef.current.initialState);\n    // Compose the default state above with any user state. This will allow the user\n    // to only control a subset of the state if desired.\n    tableRef.current.setOptions((prev)=>({\n            ...prev,\n            ...options,\n            state: {\n                ...state,\n                ...options.state\n            },\n            // Similarly, we'll maintain both our internal state and any user-provided\n            // state.\n            onStateChange: (updater)=>{\n                setState(updater);\n                options.onStateChange == null || options.onStateChange(updater);\n            }\n        }));\n    return tableRef.current;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7R0FTRyxHQUM0QjtBQUNvQjtBQUNkO0FBRXJDLEVBQUU7QUFFRjs7Q0FFQyxHQUNELFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUM3QixPQUFPLENBQUNELE9BQU8sT0FBT0UsaUJBQWlCRixRQUFRLFdBQVcsR0FBRUgsZ0RBQW1CLENBQUNHLE1BQU1DLFNBQVNEO0FBQ2pHO0FBQ0EsU0FBU0UsaUJBQWlCRSxTQUFTO0lBQ2pDLE9BQU9DLGlCQUFpQkQsY0FBYyxPQUFPQSxjQUFjLGNBQWNFLGtCQUFrQkY7QUFDN0Y7QUFDQSxTQUFTQyxpQkFBaUJELFNBQVM7SUFDakMsT0FBTyxPQUFPQSxjQUFjLGNBQWMsQ0FBQztRQUN6QyxNQUFNRyxRQUFRQyxPQUFPQyxjQUFjLENBQUNMO1FBQ3BDLE9BQU9HLE1BQU1HLFNBQVMsSUFBSUgsTUFBTUcsU0FBUyxDQUFDUixnQkFBZ0I7SUFDNUQ7QUFDRjtBQUNBLFNBQVNJLGtCQUFrQkYsU0FBUztJQUNsQyxPQUFPLE9BQU9BLGNBQWMsWUFBWSxPQUFPQSxVQUFVTyxRQUFRLEtBQUssWUFBWTtRQUFDO1FBQWM7S0FBb0IsQ0FBQ0MsUUFBUSxDQUFDUixVQUFVTyxRQUFRLENBQUNFLFdBQVc7QUFDL0o7QUFDQSxTQUFTQyxjQUFjQyxPQUFPO0lBQzVCLHFEQUFxRDtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEJDLE9BQU8sQ0FBQztRQUNSLGNBQWM7UUFDZEMsZUFBZSxLQUFPO1FBQ3RCLE9BQU87UUFDUEMscUJBQXFCO1FBQ3JCLEdBQUdKLE9BQU87SUFDWjtJQUVBLDJDQUEyQztJQUMzQyxNQUFNLENBQUNLLFNBQVMsR0FBR3ZCLDJDQUFjLENBQUMsSUFBTztZQUN2Q3lCLFNBQVN4QixpRUFBV0EsQ0FBQ2tCO1FBQ3ZCO0lBRUEsc0VBQXNFO0lBQ3RFLE1BQU0sQ0FBQ0MsT0FBT00sU0FBUyxHQUFHMUIsMkNBQWMsQ0FBQyxJQUFNdUIsU0FBU0UsT0FBTyxDQUFDRSxZQUFZO0lBRTVFLGdGQUFnRjtJQUNoRixvREFBb0Q7SUFDcERKLFNBQVNFLE9BQU8sQ0FBQ0csVUFBVSxDQUFDQyxDQUFBQSxPQUFTO1lBQ25DLEdBQUdBLElBQUk7WUFDUCxHQUFHWCxPQUFPO1lBQ1ZFLE9BQU87Z0JBQ0wsR0FBR0EsS0FBSztnQkFDUixHQUFHRixRQUFRRSxLQUFLO1lBQ2xCO1lBQ0EsMEVBQTBFO1lBQzFFLFNBQVM7WUFDVEMsZUFBZVMsQ0FBQUE7Z0JBQ2JKLFNBQVNJO2dCQUNUWixRQUFRRyxhQUFhLElBQUksUUFBUUgsUUFBUUcsYUFBYSxDQUFDUztZQUN6RDtRQUNGO0lBQ0EsT0FBT1AsU0FBU0UsT0FBTztBQUN6QjtBQUVxQyxDQUNyQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXVpLWNoYWtyYS1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanM/YTE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgICogcmVhY3QtdGFibGVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZSB9IGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcblxuLy9cblxuLyoqXG4gKiBJZiByZW5kZXJpbmcgaGVhZGVycywgY2VsbHMsIG9yIGZvb3RlcnMgd2l0aCBjdXN0b20gbWFya3VwLCB1c2UgZmxleFJlbmRlciBpbnN0ZWFkIG9mIGBjZWxsLmdldFZhbHVlKClgIG9yIGBjZWxsLnJlbmRlclZhbHVlKClgLlxuICovXG5mdW5jdGlvbiBmbGV4UmVuZGVyKENvbXAsIHByb3BzKSB7XG4gIHJldHVybiAhQ29tcCA/IG51bGwgOiBpc1JlYWN0Q29tcG9uZW50KENvbXApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgKCgpID0+IHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21wb25lbnQpO1xuICAgIHJldHVybiBwcm90by5wcm90b3R5cGUgJiYgcHJvdG8ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XG59XG5mdW5jdGlvbiB1c2VSZWFjdFRhYmxlKG9wdGlvbnMpIHtcbiAgLy8gQ29tcG9zZSBpbiB0aGUgZ2VuZXJpYyBvcHRpb25zIHRvIHRoZSB1c2VyIG9wdGlvbnNcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgIHN0YXRlOiB7fSxcbiAgICAvLyBEdW1teSBzdGF0ZVxuICAgIG9uU3RhdGVDaGFuZ2U6ICgpID0+IHt9LFxuICAgIC8vIG5vb3BcbiAgICByZW5kZXJGYWxsYmFja1ZhbHVlOiBudWxsLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgYW5kIHN0b3JlIGl0IGluIHN0YXRlXG4gIGNvbnN0IFt0YWJsZVJlZl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGN1cnJlbnQ6IGNyZWF0ZVRhYmxlKHJlc29sdmVkT3B0aW9ucylcbiAgfSkpO1xuXG4gIC8vIEJ5IGRlZmF1bHQsIG1hbmFnZSB0YWJsZSBzdGF0ZSBoZXJlIHVzaW5nIHRoZSB0YWJsZSdzIGluaXRpYWwgc3RhdGVcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB0YWJsZVJlZi5jdXJyZW50LmluaXRpYWxTdGF0ZSk7XG5cbiAgLy8gQ29tcG9zZSB0aGUgZGVmYXVsdCBzdGF0ZSBhYm92ZSB3aXRoIGFueSB1c2VyIHN0YXRlLiBUaGlzIHdpbGwgYWxsb3cgdGhlIHVzZXJcbiAgLy8gdG8gb25seSBjb250cm9sIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZSBpZiBkZXNpcmVkLlxuICB0YWJsZVJlZi5jdXJyZW50LnNldE9wdGlvbnMocHJldiA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzdGF0ZToge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5vcHRpb25zLnN0YXRlXG4gICAgfSxcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxuICAgIC8vIHN0YXRlLlxuICAgIG9uU3RhdGVDaGFuZ2U6IHVwZGF0ZXIgPT4ge1xuICAgICAgc2V0U3RhdGUodXBkYXRlcik7XG4gICAgICBvcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCBvcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB0YWJsZVJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBmbGV4UmVuZGVyLCB1c2VSZWFjdFRhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVUYWJsZSIsImZsZXhSZW5kZXIiLCJDb21wIiwicHJvcHMiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudCIsImlzQ2xhc3NDb21wb25lbnQiLCJpc0V4b3RpY0NvbXBvbmVudCIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCIkJHR5cGVvZiIsImluY2x1ZGVzIiwiZGVzY3JpcHRpb24iLCJ1c2VSZWFjdFRhYmxlIiwib3B0aW9ucyIsInJlc29sdmVkT3B0aW9ucyIsInN0YXRlIiwib25TdGF0ZUNoYW5nZSIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJ0YWJsZVJlZiIsInVzZVN0YXRlIiwiY3VycmVudCIsInNldFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic2V0T3B0aW9ucyIsInByZXYiLCJ1cGRhdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* binding */ ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* binding */ ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* binding */ ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* binding */ ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* binding */ ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* binding */ ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* binding */ GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* binding */ GlobalFiltering),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   RowExpanding: () => (/* binding */ RowExpanding),\n/* harmony export */   RowPagination: () => (/* binding */ RowPagination),\n/* harmony export */   RowPinning: () => (/* binding */ RowPinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   RowSorting: () => (/* binding */ RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* binding */ _getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* binding */ getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ // type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\n// Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return (depArgs)=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps(depArgs);\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction getMemoOptions(tableOptions, debugLevel, key, onChange) {\n    return {\n        debug: ()=>{\n            var _tableOptions$debugAl;\n            return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];\n        },\n        key:  true && key,\n        onChange\n    };\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), getMemoOptions(table.options, \"debugCells\", \"cell.getContext\"))\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === \"function\" ? accessorKey.replaceAll(\".\", \"_\") : accessorKey.replace(/\\./g, \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getFlatColumns\")),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getLeafColumns\"))\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to unknown, because we know more than the compiler here.\n    return column;\n}\nconst debug = \"debugHeaders\";\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, getMemoOptions(table.options, debug, \"getHeaderGroups\"));\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, getMemoOptions(table.options, debug, \"getCenterHeaderGroups\"));\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, getMemoOptions(table.options, debug, \"getLeftHeaderGroups\"));\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, getMemoOptions(table.options, debug, \"getRightHeaderGroups\"));\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getFooterGroups\"));\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getLeftFooterGroups\"));\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getCenterFooterGroups\"));\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getRightFooterGroups\"));\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getFlatHeaders\"));\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeftFlatHeaders\"));\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getCenterFlatHeaders\"));\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getRightFlatHeaders\"));\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getCenterLeafHeaders\"));\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getLeftLeafHeaders\"));\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getRightLeafHeaders\"));\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeafHeaders\"));\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCells\")),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCellsByColumnId\"))\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n//\nconst ColumnFaceting = {\n    createColumn: (column, table)=>{\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _filterValue$toString, _row$getValue;\n    const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst ColumnFiltering = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousFilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousFilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n    },\n    createRow: (row, _table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst ColumnGrouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst ColumnOrdering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getIndex = memo((position)=>[\n                _getVisibleLeafColumns(table, position)\n            ], (columns)=>columns.findIndex((d)=>d.id === column.id), getMemoOptions(table.options, \"debugColumns\", \"getIndex\"));\n        column.getIsFirstColumn = (position)=>{\n            var _columns$;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;\n        };\n        column.getIsLastColumn = (position)=>{\n            var _columns;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, getMemoOptions(table.options, \"debugTable\", \"_getOrderColumnsFn\"));\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst ColumnPinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterVisibleCells\"));\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left\n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getLeftVisibleCells\"));\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getRightVisibleCells\"));\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getLeftLeafColumns\"));\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getRightLeafColumns\"));\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, getMemoOptions(table.options, \"debugColumns\", \"getCenterLeafColumns\"));\n    }\n};\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            columnResizeDirection: \"ltr\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(0, column.getIndex(position)).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getStart\"));\n        column.getAfter = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(column.getIndex(position) + 1).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getAfter\"));\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = (_contextDocument)=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaDirection = table.options.columnResizeDirection === \"rtl\" ? -1 : 1;\n                        const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const contextDocument = _contextDocument || typeof document !== \"undefined\" ? document : null;\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        contextDocument == null || contextDocument.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        contextDocument == null || contextDocument.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    contextDocument == null || contextDocument.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    contextDocument == null || contextDocument.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst ColumnVisibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _ref, _table$getState$colum;\n            const childColumns = column.columns;\n            return (_ref = childColumns.length ? childColumns.some((c)=>c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, getMemoOptions(table.options, \"debugRows\", \"_getAllVisibleCells\"));\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], getMemoOptions(table.options, \"debugRows\", \"getVisibleCells\"));\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, getMemoOptions(table.options, \"debugColumns\", key));\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nfunction _getVisibleLeafColumns(table, position) {\n    return !position ? table.getVisibleLeafColumns() : position === \"center\" ? table.getCenterVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n}\n//\nconst GlobalFaceting = {\n    createTable: (table)=>{\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\n//\nconst GlobalFiltering = {\n    getInitialState: (state)=>{\n        return {\n            globalFilter: undefined,\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;\n            return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n    }\n};\n//\nconst RowExpanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst RowPagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        //deprecated\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPageOptions\"));\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.firstPage = ()=>{\n            return table.setPageIndex(0);\n        };\n        table.lastPage = ()=>{\n            return table.setPageIndex(table.getPageCount() - 1);\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);\n        };\n        table.getRowCount = ()=>{\n            var _table$options$rowCou;\n            return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;\n        };\n    }\n};\n//\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst RowPinning = {\n    getInitialState: (state)=>{\n        return {\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref)=>{\n                let { id } = _ref;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref3;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _ref4, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_ref4 = position === \"top\" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5)=>{\n                let { id } = _ref5;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n    },\n    createTable: (table)=>{\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table._getPinnedRows = (visibleRows, pinnedRowIds, position)=>{\n            var _table$options$keepPi;\n            const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n            //account for expanded parent rows, but not pagination or filtering\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                const row = table.getRow(rowId, true);\n                return row.getIsAllParentsExpanded() ? row : null;\n            }) : //else get only visible rows that are pinned\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n            return rows.filter(Boolean).map((d)=>({\n                    ...d,\n                    position\n                }));\n        };\n        table.getTopRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top\n            ], (allRows, topPinnedRowIds)=>table._getPinnedRows(allRows, topPinnedRowIds, \"top\"), getMemoOptions(table.options, \"debugRows\", \"getTopRows\"));\n        table.getBottomRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.bottom\n            ], (allRows, bottomPinnedRowIds)=>table._getPinnedRows(allRows, bottomPinnedRowIds, \"bottom\"), getMemoOptions(table.options, \"debugRows\", \"getBottomRows\"));\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterRows\"));\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getSelectedRowModel\"));\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredSelectedRowModel\"));\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedSelectedRowModel\"));\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id, true);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst RowSorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\nconst builtInFeatures = [\n    Headers,\n    ColumnVisibility,\n    ColumnOrdering,\n    ColumnPinning,\n    ColumnFaceting,\n    ColumnFiltering,\n    GlobalFaceting,\n    //depends on ColumnFaceting\n    GlobalFiltering,\n    //depends on ColumnFiltering\n    RowSorting,\n    ColumnGrouping,\n    //depends on RowSorting\n    RowExpanding,\n    RowPagination,\n    RowPinning,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$_features, _options$initialState;\n    if ( true && (options.debugAll || options.debugTable)) {\n        console.info(\"Creating Table Instance...\");\n    }\n    const _features = [\n        ...builtInFeatures,\n        ...(_options$_features = options._features) != null ? _options$_features : []\n    ];\n    let table = {\n        _features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        //in next version, we should just pass in the row model as the optional 2nd arg\n        getRow: (id, searchAll)=>{\n            let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                row = table.getCoreRowModel().rowsById[id];\n                if (!row) {\n                    if (true) {\n                        throw new Error(`getRow could not find row with ID: ${id}`);\n                    }\n                    throw new Error();\n                }\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, getMemoOptions(options, \"debugColumns\", \"_getDefaultColumnDef\")),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllColumns\")),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumns\")),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumnsById\")),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllLeafColumns\")),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getExpandedRowModel\"));\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return undefined;\n            const uniqueValues = facetedRowModel.flatRows.flatMap((flatRow)=>{\n                var _flatRow$getUniqueVal;\n                return (_flatRow$getUniqueVal = flatRow.getUniqueValues(columnId)) != null ? _flatRow$getUniqueVal : [];\n            }).map(Number).filter((value)=>!Number.isNaN(value));\n            if (!uniqueValues.length) return;\n            let facetedMinValue = uniqueValues[0];\n            let facetedMaxValue = uniqueValues[uniqueValues.length - 1];\n            for (const value of uniqueValues){\n                if (value < facetedMinValue) facetedMinValue = value;\n                else if (value > facetedMaxValue) facetedMaxValue = value;\n            }\n            return [\n                facetedMinValue,\n                facetedMaxValue\n            ];\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedMinMaxValues\"));\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedRowModel\"));\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, getMemoOptions(table.options, \"debugTable\", `getFacetedUniqueValues_${columnId}`));\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = (columnFilters != null ? columnFilters : []).map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                rowModel.rows.forEach((row)=>{\n                    row.depth = 0;\n                    row.parentId = undefined;\n                });\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Perform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    subRows.forEach((subRow)=>{\n                        subRow.parentId = id;\n                    });\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedRowModel\", ()=>{\n            table._queue(()=>{\n                table._autoResetExpanded();\n                table._autoResetPageIndex();\n            });\n        }));\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPaginationRowModel\"));\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const sortUndefined = columnInfo.sortUndefined;\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                if (sortUndefined === \"first\") return aUndefined ? -1 : 1;\n                                if (sortUndefined === \"last\") return aUndefined ? 1 : -1;\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getSortedRowModel\", ()=>table._autoResetPageIndex()));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0dBU0csR0FDSCxrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxhQUFhO0FBQ2IsVUFBVTtBQUNWLHFCQUFxQjtBQUNyQixVQUFVO0FBQ1YsUUFBUTtBQUNSLGlDQUFpQztBQUNqQyxhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixxQkFBcUI7QUFDckIsVUFBVTtBQUNWLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUVKLG9EQUFvRDtBQUNwRCwrQ0FBK0M7QUFFL0MsOENBQThDO0FBRTlDLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsS0FBSztBQUVMLHdDQUF3QztBQUN4QyxtQ0FBbUM7QUFDbkMsS0FBSztBQUVMLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsS0FBSztBQUVMLFNBQVNBO0lBQ1AsT0FBTztRQUNMQyxVQUFVLENBQUNBLFVBQVVDO1lBQ25CLE9BQU8sT0FBT0QsYUFBYSxhQUFhO2dCQUN0QyxHQUFHQyxNQUFNO2dCQUNUQyxZQUFZRjtZQUNkLElBQUk7Z0JBQ0YsR0FBR0MsTUFBTTtnQkFDVEUsYUFBYUg7WUFDZjtRQUNGO1FBQ0FJLFNBQVNILENBQUFBLFNBQVVBO1FBQ25CSSxPQUFPSixDQUFBQSxTQUFVQTtJQUNuQjtBQUNGO0FBRUEsd0JBQXdCO0FBRXhCLHFEQUFxRDtBQUVyRCxHQUFHO0FBRUgsU0FBU0ssaUJBQWlCQyxPQUFPLEVBQUVDLEtBQUs7SUFDdEMsT0FBTyxPQUFPRCxZQUFZLGFBQWFBLFFBQVFDLFNB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Q2pCLElBQUlELFFBQVE7Z0NBQ1ZDLFdBQVcsQ0FBQzs0QkFDZDs0QkFDQSxJQUFJRixXQUFXSixhQUFhLEVBQUU7Z0NBQzVCTSxXQUFXLENBQUM7NEJBQ2Q7NEJBQ0EsT0FBT0E7d0JBQ1Q7b0JBQ0Y7b0JBQ0EsT0FBT3RMLEtBQUtydEIsS0FBSyxHQUFHc3RCLEtBQUt0dEIsS0FBSztnQkFDaEM7Z0JBRUEsbUNBQW1DO2dCQUNuQ3U0QixXQUFXMzVCLE9BQU8sQ0FBQzRDLENBQUFBO29CQUNqQixJQUFJa1Q7b0JBQ0p1akIsZUFBZW41QixJQUFJLENBQUMwQztvQkFDcEIsSUFBSSxDQUFDa1QsZUFBZWxULElBQUlpSSxPQUFPLEtBQUssUUFBUWlMLGFBQWExVixNQUFNLEVBQUU7d0JBQy9Ed0MsSUFBSWlJLE9BQU8sR0FBRzZ1QixTQUFTOTJCLElBQUlpSSxPQUFPO29CQUNwQztnQkFDRjtnQkFDQSxPQUFPOHVCO1lBQ1Q7WUFDQSxPQUFPO2dCQUNMelIsTUFBTXdSLFNBQVMzTixTQUFTN0QsSUFBSTtnQkFDNUJ4WSxVQUFVMnBCO2dCQUNWclYsVUFBVStILFNBQVMvSCxRQUFRO1lBQzdCO1FBQ0YsR0FBRzVoQixlQUFlTyxNQUFNTyxPQUFPLEVBQUUsY0FBYyxxQkFBcUIsSUFBTVAsTUFBTWlqQixtQkFBbUI7QUFDckc7QUFFbzBCLENBQ3AwQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXVpLWNoYWtyYS1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcz81NTZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiB0YWJsZS1jb3JlXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICpcbiAgICogQGxpY2Vuc2UgTUlUXG4gICAqL1xuLy8gdHlwZSBQZXJzb24gPSB7XG4vLyAgIGZpcnN0TmFtZTogc3RyaW5nXG4vLyAgIGxhc3ROYW1lOiBzdHJpbmdcbi8vICAgYWdlOiBudW1iZXJcbi8vICAgdmlzaXRzOiBudW1iZXJcbi8vICAgc3RhdHVzOiBzdHJpbmdcbi8vICAgcHJvZ3Jlc3M6IG51bWJlclxuLy8gICBjcmVhdGVkQXQ6IERhdGVcbi8vICAgbmVzdGVkOiB7XG4vLyAgICAgZm9vOiBbXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGJhcjogJ2Jhcidcbi8vICAgICAgIH1cbi8vICAgICBdXG4vLyAgICAgYmFyOiB7IHN1YkJhcjogYm9vbGVhbiB9W11cbi8vICAgICBiYXo6IHtcbi8vICAgICAgIGZvbzogJ2Zvbydcbi8vICAgICAgIGJhcjoge1xuLy8gICAgICAgICBiYXo6ICdiYXonXG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cbi8vIGNvbnN0IHRlc3Q6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmZvby4wLmJhcidcbi8vIGNvbnN0IHRlc3QyOiBEZWVwS2V5czxQZXJzb24+ID0gJ25lc3RlZC5iYXInXG5cbi8vIGNvbnN0IGhlbHBlciA9IGNyZWF0ZUNvbHVtbkhlbHBlcjxQZXJzb24+KClcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuZm9vJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvby4wLmJhcicsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5iYXInLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuZnVuY3Rpb24gY3JlYXRlQ29sdW1uSGVscGVyKCkge1xuICByZXR1cm4ge1xuICAgIGFjY2Vzc29yOiAoYWNjZXNzb3IsIGNvbHVtbikgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICBhY2Nlc3NvckZuOiBhY2Nlc3NvclxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICBhY2Nlc3NvcktleTogYWNjZXNzb3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBkaXNwbGF5OiBjb2x1bW4gPT4gY29sdW1uLFxuICAgIGdyb3VwOiBjb2x1bW4gPT4gY29sdW1uXG4gIH07XG59XG5cbi8vIElzIHRoaXMgdHlwZSBhIHR1cGxlP1xuXG4vLyBJZiB0aGlzIHR5cGUgaXMgYSB0dXBsZSwgd2hhdCBpbmRpY2VzIGFyZSBhbGxvd2VkP1xuXG4vLy9cblxuZnVuY3Rpb24gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIHVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyB1cGRhdGVyKGlucHV0KSA6IHVwZGF0ZXI7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAvL1xufVxuZnVuY3Rpb24gbWFrZVN0YXRlVXBkYXRlcihrZXksIGluc3RhbmNlKSB7XG4gIHJldHVybiB1cGRhdGVyID0+IHtcbiAgICBpbnN0YW5jZS5zZXRTdGF0ZShvbGQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub2xkLFxuICAgICAgICBba2V5XTogZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGRba2V5XSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGQpIHtcbiAgcmV0dXJuIGQgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoZCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkKSAmJiBkLmV2ZXJ5KHZhbCA9PiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyk7XG59XG5mdW5jdGlvbiBmbGF0dGVuQnkoYXJyLCBnZXRDaGlsZHJlbikge1xuICBjb25zdCBmbGF0ID0gW107XG4gIGNvbnN0IHJlY3Vyc2UgPSBzdWJBcnIgPT4ge1xuICAgIHN1YkFyci5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgZmxhdC5wdXNoKGl0ZW0pO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpdGVtKTtcbiAgICAgIGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZWN1cnNlKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmVjdXJzZShhcnIpO1xuICByZXR1cm4gZmxhdDtcbn1cbmZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcbiAgbGV0IGRlcHMgPSBbXTtcbiAgbGV0IHJlc3VsdDtcbiAgcmV0dXJuIGRlcEFyZ3MgPT4ge1xuICAgIGxldCBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSBkZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBuZXdEZXBzID0gZ2V0RGVwcyhkZXBBcmdzKTtcbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoKGRlcCwgaW5kZXgpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIGxldCByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSByZXN1bHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXN1bHQgPSBmbiguLi5uZXdEZXBzKTtcbiAgICBvcHRzID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZSA9PSBudWxsIHx8IG9wdHMub25DaGFuZ2UocmVzdWx0KTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1Zykge1xuICAgICAgaWYgKG9wdHMgIT0gbnVsbCAmJiBvcHRzLmRlYnVnKCkpIHtcbiAgICAgICAgY29uc3QgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gcmVzdWx0VGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgICBjb25zdCByZXN1bHRGcHNQZXJjZW50YWdlID0gcmVzdWx0RW5kVGltZSAvIDE2O1xuICAgICAgICBjb25zdCBwYWQgPSAoc3RyLCBudW0pID0+IHtcbiAgICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAgICAgc3RyID0gJyAnICsgc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmluZm8oYCVj4o+xICR7cGFkKHJlc3VsdEVuZFRpbWUsIDUpfSAvJHtwYWQoZGVwRW5kVGltZSwgNSl9IG1zYCwgYFxuICAgICAgICAgICAgZm9udC1zaXplOiAuNnJlbTtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgY29sb3I6IGhzbCgke01hdGgubWF4KDAsIE1hdGgubWluKDEyMCAtIDEyMCAqIHJlc3VsdEZwc1BlcmNlbnRhZ2UsIDEyMCkpfWRlZyAxMDAlIDMxJSk7YCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0TWVtb09wdGlvbnModGFibGVPcHRpb25zLCBkZWJ1Z0xldmVsLCBrZXksIG9uQ2hhbmdlKSB7XG4gIHJldHVybiB7XG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGVPcHRpb25zJGRlYnVnQWw7XG4gICAgICByZXR1cm4gKF90YWJsZU9wdGlvbnMkZGVidWdBbCA9IHRhYmxlT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogdGFibGVPcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlT3B0aW9ucyRkZWJ1Z0FsIDogdGFibGVPcHRpb25zW2RlYnVnTGV2ZWxdO1xuICAgIH0sXG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBrZXksXG4gICAgb25DaGFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2VsbCh0YWJsZSwgcm93LCBjb2x1bW4sIGNvbHVtbklkKSB7XG4gIGNvbnN0IGdldFJlbmRlclZhbHVlID0gKCkgPT4ge1xuICAgIHZhciBfY2VsbCRnZXRWYWx1ZTtcbiAgICByZXR1cm4gKF9jZWxsJGdldFZhbHVlID0gY2VsbC5nZXRWYWx1ZSgpKSAhPSBudWxsID8gX2NlbGwkZ2V0VmFsdWUgOiB0YWJsZS5vcHRpb25zLnJlbmRlckZhbGxiYWNrVmFsdWU7XG4gIH07XG4gIGNvbnN0IGNlbGwgPSB7XG4gICAgaWQ6IGAke3Jvdy5pZH1fJHtjb2x1bW4uaWR9YCxcbiAgICByb3csXG4gICAgY29sdW1uLFxuICAgIGdldFZhbHVlOiAoKSA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpLFxuICAgIHJlbmRlclZhbHVlOiBnZXRSZW5kZXJWYWx1ZSxcbiAgICBnZXRDb250ZXh0OiBtZW1vKCgpID0+IFt0YWJsZSwgY29sdW1uLCByb3csIGNlbGxdLCAodGFibGUsIGNvbHVtbiwgcm93LCBjZWxsKSA9PiAoe1xuICAgICAgdGFibGUsXG4gICAgICBjb2x1bW4sXG4gICAgICByb3csXG4gICAgICBjZWxsOiBjZWxsLFxuICAgICAgZ2V0VmFsdWU6IGNlbGwuZ2V0VmFsdWUsXG4gICAgICByZW5kZXJWYWx1ZTogY2VsbC5yZW5kZXJWYWx1ZVxuICAgIH0pLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDZWxscycsICdjZWxsLmdldENvbnRleHQnKSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgZmVhdHVyZS5jcmVhdGVDZWxsID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVDZWxsKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGNlbGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KSB7XG4gIHZhciBfcmVmLCBfcmVzb2x2ZWRDb2x1bW5EZWYkaWQ7XG4gIGNvbnN0IGRlZmF1bHRDb2x1bW4gPSB0YWJsZS5fZ2V0RGVmYXVsdENvbHVtbkRlZigpO1xuICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHtcbiAgICAuLi5kZWZhdWx0Q29sdW1uLFxuICAgIC4uLmNvbHVtbkRlZlxuICB9O1xuICBjb25zdCBhY2Nlc3NvcktleSA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xuICBsZXQgaWQgPSAoX3JlZiA9IChfcmVzb2x2ZWRDb2x1bW5EZWYkaWQgPSByZXNvbHZlZENvbHVtbkRlZi5pZCkgIT0gbnVsbCA/IF9yZXNvbHZlZENvbHVtbkRlZiRpZCA6IGFjY2Vzc29yS2V5ID8gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbCA9PT0gJ2Z1bmN0aW9uJyA/IGFjY2Vzc29yS2V5LnJlcGxhY2VBbGwoJy4nLCAnXycpIDogYWNjZXNzb3JLZXkucmVwbGFjZSgvXFwuL2csICdfJykgOiB1bmRlZmluZWQpICE9IG51bGwgPyBfcmVmIDogdHlwZW9mIHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA9PT0gJ3N0cmluZycgPyByZXNvbHZlZENvbHVtbkRlZi5oZWFkZXIgOiB1bmRlZmluZWQ7XG4gIGxldCBhY2Nlc3NvckZuO1xuICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgIGFjY2Vzc29yRm4gPSByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuO1xuICB9IGVsc2UgaWYgKGFjY2Vzc29yS2V5KSB7XG4gICAgLy8gU3VwcG9ydCBkZWVwIGFjY2Vzc29yIGtleXNcbiAgICBpZiAoYWNjZXNzb3JLZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG9yaWdpbmFsUm93O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY2Nlc3NvcktleS5zcGxpdCgnLicpKSB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0ID0gKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0W2tleV07XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCIke2tleX1cIiBpbiBkZWVwbHkgbmVzdGVkIGtleSBcIiR7YWNjZXNzb3JLZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IG9yaWdpbmFsUm93W3Jlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbiA/IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhbiBhY2Nlc3NvckZuYCA6IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhIG5vbi1zdHJpbmcgaGVhZGVyYCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIGxldCBjb2x1bW4gPSB7XG4gICAgaWQ6IGAke1N0cmluZyhpZCl9YCxcbiAgICBhY2Nlc3NvckZuLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGRlcHRoLFxuICAgIGNvbHVtbkRlZjogcmVzb2x2ZWRDb2x1bW5EZWYsXG4gICAgY29sdW1uczogW10sXG4gICAgZ2V0RmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RydWVdLCAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zO1xuICAgICAgcmV0dXJuIFtjb2x1bW4sIC4uLigoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1uJGNvbHVtbnMuZmxhdE1hcChkID0+IGQuZ2V0RmxhdENvbHVtbnMoKSkpXTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2NvbHVtbi5nZXRGbGF0Q29sdW1ucycpKSxcbiAgICBnZXRMZWFmQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCBvcmRlckNvbHVtbnMgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uczI7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1uczIgPSBjb2x1bW4uY29sdW1ucykgIT0gbnVsbCAmJiBfY29sdW1uJGNvbHVtbnMyLmxlbmd0aCkge1xuICAgICAgICBsZXQgbGVhZkNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtjb2x1bW5dO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnY29sdW1uLmdldExlYWZDb2x1bW5zJykpXG4gIH07XG4gIGZvciAoY29uc3QgZmVhdHVyZSBvZiB0YWJsZS5fZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNvbHVtbiA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlQ29sdW1uKGNvbHVtbiwgdGFibGUpO1xuICB9XG5cbiAgLy8gWWVzLCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGFibGUgdG8gdW5rbm93biwgYmVjYXVzZSB3ZSBrbm93IG1vcmUgdGhhbiB0aGUgY29tcGlsZXIgaGVyZS5cbiAgcmV0dXJuIGNvbHVtbjtcbn1cblxuY29uc3QgZGVidWcgPSAnZGVidWdIZWFkZXJzJztcbi8vXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRpZDtcbiAgY29uc3QgaWQgPSAoX29wdGlvbnMkaWQgPSBvcHRpb25zLmlkKSAhPSBudWxsID8gX29wdGlvbnMkaWQgOiBjb2x1bW4uaWQ7XG4gIGxldCBoZWFkZXIgPSB7XG4gICAgaWQsXG4gICAgY29sdW1uLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgIGlzUGxhY2Vob2xkZXI6ICEhb3B0aW9ucy5pc1BsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVySWQ6IG9wdGlvbnMucGxhY2Vob2xkZXJJZCxcbiAgICBkZXB0aDogb3B0aW9ucy5kZXB0aCxcbiAgICBzdWJIZWFkZXJzOiBbXSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIHJvd1NwYW46IDAsXG4gICAgaGVhZGVyR3JvdXA6IG51bGwsXG4gICAgZ2V0TGVhZkhlYWRlcnM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZIZWFkZXJzID0gW107XG4gICAgICBjb25zdCByZWN1cnNlSGVhZGVyID0gaCA9PiB7XG4gICAgICAgIGlmIChoLnN1YkhlYWRlcnMgJiYgaC5zdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGguc3ViSGVhZGVycy5tYXAocmVjdXJzZUhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGVhZkhlYWRlcnMucHVzaChoKTtcbiAgICAgIH07XG4gICAgICByZWN1cnNlSGVhZGVyKGhlYWRlcik7XG4gICAgICByZXR1cm4gbGVhZkhlYWRlcnM7XG4gICAgfSxcbiAgICBnZXRDb250ZXh0OiAoKSA9PiAoe1xuICAgICAgdGFibGUsXG4gICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgIGNvbHVtblxuICAgIH0pXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIGZlYXR1cmUuY3JlYXRlSGVhZGVyID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVIZWFkZXIoaGVhZGVyLCB0YWJsZSk7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVyO1xufVxuY29uc3QgSGVhZGVycyA9IHtcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICAvLyBIZWFkZXIgR3JvdXBzXG5cbiAgICB0YWJsZS5nZXRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JG1hcCRmaWx0ZXIsIF9yaWdodCRtYXAkZmlsdGVyO1xuICAgICAgY29uc3QgbGVmdENvbHVtbnMgPSAoX2xlZnQkbWFwJGZpbHRlciA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIgOiBbXTtcbiAgICAgIGNvbnN0IHJpZ2h0Q29sdW1ucyA9IChfcmlnaHQkbWFwJGZpbHRlciA9IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX3JpZ2h0JG1hcCRmaWx0ZXIgOiBbXTtcbiAgICAgIGNvbnN0IGNlbnRlckNvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICEobGVmdCAhPSBudWxsICYmIGxlZnQuaW5jbHVkZXMoY29sdW1uLmlkKSkgJiYgIShyaWdodCAhPSBudWxsICYmIHJpZ2h0LmluY2x1ZGVzKGNvbHVtbi5pZCkpKTtcbiAgICAgIGNvbnN0IGhlYWRlckdyb3VwcyA9IGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIFsuLi5sZWZ0Q29sdW1ucywgLi4uY2VudGVyQ29sdW1ucywgLi4ucmlnaHRDb2x1bW5zXSwgdGFibGUpO1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3VwcztcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgbGVhZkNvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICEobGVmdCAhPSBudWxsICYmIGxlZnQuaW5jbHVkZXMoY29sdW1uLmlkKSkgJiYgIShyaWdodCAhPSBudWxsICYmIHJpZ2h0LmluY2x1ZGVzKGNvbHVtbi5pZCkpKTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgdGFibGUsICdjZW50ZXInKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldENlbnRlckhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgIHZhciBfbGVmdCRtYXAkZmlsdGVyMjtcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyMiA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ2xlZnQnKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlZnRIZWFkZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX3JpZ2h0JG1hcCRmaWx0ZXIyO1xuICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyMiA9IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX3JpZ2h0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ3JpZ2h0Jyk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEhlYWRlckdyb3VwcycpKTtcblxuICAgIC8vIEZvb3RlciBHcm91cHNcblxuICAgIHRhYmxlLmdldEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRGb290ZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdEZvb3Rlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVyRm9vdGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0UmlnaHRGb290ZXJHcm91cHMnKSk7XG5cbiAgICAvLyBGbGF0IEhlYWRlcnNcblxuICAgIHRhYmxlLmdldEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwcy5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZsYXRIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldExlZnRGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0RmxhdEhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJGbGF0SGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZsYXRIZWFkZXJzJykpO1xuXG4gICAgLy8gTGVhZiBIZWFkZXJzXG5cbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnM7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMgPSBoZWFkZXIuc3ViSGVhZGVycykgIT0gbnVsbCAmJiBfaGVhZGVyJHN1YkhlYWRlcnMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVyTGVhZkhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMyO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMiA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczIubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdExlYWZIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMzO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0UmlnaHRMZWFmSGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCksIHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCAobGVmdCwgY2VudGVyLCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JDAkaGVhZGVycywgX2xlZnQkLCBfY2VudGVyJDAkaGVhZGVycywgX2NlbnRlciQsIF9yaWdodCQwJGhlYWRlcnMsIF9yaWdodCQ7XG4gICAgICByZXR1cm4gWy4uLigoX2xlZnQkMCRoZWFkZXJzID0gKF9sZWZ0JCA9IGxlZnRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbGVmdCQuaGVhZGVycykgIT0gbnVsbCA/IF9sZWZ0JDAkaGVhZGVycyA6IFtdKSwgLi4uKChfY2VudGVyJDAkaGVhZGVycyA9IChfY2VudGVyJCA9IGNlbnRlclswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jZW50ZXIkLmhlYWRlcnMpICE9IG51bGwgPyBfY2VudGVyJDAkaGVhZGVycyA6IFtdKSwgLi4uKChfcmlnaHQkMCRoZWFkZXJzID0gKF9yaWdodCQgPSByaWdodFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yaWdodCQuaGVhZGVycykgIT0gbnVsbCA/IF9yaWdodCQwJGhlYWRlcnMgOiBbXSldLm1hcChoZWFkZXIgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyLmdldExlYWZIZWFkZXJzKCk7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWFmSGVhZGVycycpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGNvbHVtbnNUb0dyb3VwLCB0YWJsZSwgaGVhZGVyRmFtaWx5KSB7XG4gIHZhciBfaGVhZGVyR3JvdXBzJDAkaGVhZGUsIF9oZWFkZXJHcm91cHMkO1xuICAvLyBGaW5kIHRoZSBtYXggZGVwdGggb2YgdGhlIGNvbHVtbnM6XG4gIC8vIGJ1aWxkIHRoZSBsZWFmIGNvbHVtbiByb3dcbiAgLy8gYnVpbGQgZWFjaCBidWZmZXIgcm93IGdvaW5nIHVwXG4gIC8vICAgIHBsYWNlaG9sZGVyIGZvciBub24tZXhpc3RlbnQgbGV2ZWxcbiAgLy8gICAgcmVhbCBjb2x1bW4gZm9yIGV4aXN0aW5nIGxldmVsXG5cbiAgbGV0IG1heERlcHRoID0gMDtcbiAgY29uc3QgZmluZE1heERlcHRoID0gZnVuY3Rpb24gKGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMTtcbiAgICB9XG4gICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgZGVwdGgpO1xuICAgIGNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zKSAhPSBudWxsICYmIF9jb2x1bW4kY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgZmluZE1heERlcHRoKGNvbHVtbi5jb2x1bW5zLCBkZXB0aCArIDEpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9O1xuICBmaW5kTWF4RGVwdGgoYWxsQ29sdW1ucyk7XG4gIGxldCBoZWFkZXJHcm91cHMgPSBbXTtcbiAgY29uc3QgY3JlYXRlSGVhZGVyR3JvdXAgPSAoaGVhZGVyc1RvR3JvdXAsIGRlcHRoKSA9PiB7XG4gICAgLy8gVGhlIGhlYWRlciBncm91cCB3ZSBhcmUgY3JlYXRpbmdcbiAgICBjb25zdCBoZWFkZXJHcm91cCA9IHtcbiAgICAgIGRlcHRoLFxuICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGAke2RlcHRofWBdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXG4gICAgICBoZWFkZXJzOiBbXVxuICAgIH07XG5cbiAgICAvLyBUaGUgcGFyZW50IGNvbHVtbnMgd2UncmUgZ29pbmcgdG8gc2NhbiBuZXh0XG4gICAgY29uc3QgcGVuZGluZ1BhcmVudEhlYWRlcnMgPSBbXTtcblxuICAgIC8vIFNjYW4gZWFjaCBjb2x1bW4gZm9yIHBhcmVudHNcbiAgICBoZWFkZXJzVG9Hcm91cC5mb3JFYWNoKGhlYWRlclRvR3JvdXAgPT4ge1xuICAgICAgLy8gV2hhdCBpcyB0aGUgbGF0ZXN0IChsYXN0KSBwYXJlbnQgY29sdW1uP1xuXG4gICAgICBjb25zdCBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID0gWy4uLnBlbmRpbmdQYXJlbnRIZWFkZXJzXS5yZXZlcnNlKClbMF07XG4gICAgICBjb25zdCBpc0xlYWZIZWFkZXIgPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5kZXB0aCA9PT0gaGVhZGVyR3JvdXAuZGVwdGg7XG4gICAgICBsZXQgY29sdW1uO1xuICAgICAgbGV0IGlzUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgIGlmIChpc0xlYWZIZWFkZXIgJiYgaGVhZGVyVG9Hcm91cC5jb2x1bW4ucGFyZW50KSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIG5ld1xuICAgICAgICBjb2x1bW4gPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcGFyZW50IGhlYWRlciBpcyByZXBlYXRlZFxuICAgICAgICBjb2x1bW4gPSBoZWFkZXJUb0dyb3VwLmNvbHVtbjtcbiAgICAgICAgaXNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciAmJiAobGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5jb2x1bW4pID09PSBjb2x1bW4pIHtcbiAgICAgICAgLy8gVGhpcyBjb2x1bW4gaXMgcmVwZWF0ZWQuIEFkZCBpdCBhcyBhIHN1YiBoZWFkZXIgdG8gdGhlIG5leHQgYmF0Y2hcbiAgICAgICAgbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5zdWJIZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGhlYWRlci4gTGV0J3MgY3JlYXRlIGl0XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCB7XG4gICAgICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGRlcHRoLCBjb2x1bW4uaWQsIGhlYWRlclRvR3JvdXAgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWRlclRvR3JvdXAuaWRdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXG4gICAgICAgICAgaXNQbGFjZWhvbGRlcixcbiAgICAgICAgICBwbGFjZWhvbGRlcklkOiBpc1BsYWNlaG9sZGVyID8gYCR7cGVuZGluZ1BhcmVudEhlYWRlcnMuZmlsdGVyKGQgPT4gZC5jb2x1bW4gPT09IGNvbHVtbikubGVuZ3RofWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgaW5kZXg6IHBlbmRpbmdQYXJlbnRIZWFkZXJzLmxlbmd0aFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGhlIGhlYWRlclRvR3JvdXAgYXMgYSBzdWJIZWFkZXIgb2YgdGhlIG5ldyBoZWFkZXJcbiAgICAgICAgaGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgaGVhZGVyIHRvIHRoZSBwZW5kaW5nUGFyZW50SGVhZGVycyB0byBnZXQgZ3JvdXBlZFxuICAgICAgICAvLyBpbiB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBwZW5kaW5nUGFyZW50SGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICB9XG4gICAgICBoZWFkZXJHcm91cC5oZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICBoZWFkZXJUb0dyb3VwLmhlYWRlckdyb3VwID0gaGVhZGVyR3JvdXA7XG4gICAgfSk7XG4gICAgaGVhZGVyR3JvdXBzLnB1c2goaGVhZGVyR3JvdXApO1xuICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgIGNyZWF0ZUhlYWRlckdyb3VwKHBlbmRpbmdQYXJlbnRIZWFkZXJzLCBkZXB0aCAtIDEpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYm90dG9tSGVhZGVycyA9IGNvbHVtbnNUb0dyb3VwLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICBkZXB0aDogbWF4RGVwdGgsXG4gICAgaW5kZXhcbiAgfSkpO1xuICBjcmVhdGVIZWFkZXJHcm91cChib3R0b21IZWFkZXJzLCBtYXhEZXB0aCAtIDEpO1xuICBoZWFkZXJHcm91cHMucmV2ZXJzZSgpO1xuXG4gIC8vIGhlYWRlckdyb3VwcyA9IGhlYWRlckdyb3Vwcy5maWx0ZXIoaGVhZGVyR3JvdXAgPT4ge1xuICAvLyAgIHJldHVybiAhaGVhZGVyR3JvdXAuaGVhZGVycy5ldmVyeShoZWFkZXIgPT4gaGVhZGVyLmlzUGxhY2Vob2xkZXIpXG4gIC8vIH0pXG5cbiAgY29uc3QgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyA9IGhlYWRlcnMgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkSGVhZGVycyA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiBoZWFkZXIuY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICByZXR1cm4gZmlsdGVyZWRIZWFkZXJzLm1hcChoZWFkZXIgPT4ge1xuICAgICAgbGV0IGNvbFNwYW4gPSAwO1xuICAgICAgbGV0IHJvd1NwYW4gPSAwO1xuICAgICAgbGV0IGNoaWxkUm93U3BhbnMgPSBbMF07XG4gICAgICBpZiAoaGVhZGVyLnN1YkhlYWRlcnMgJiYgaGVhZGVyLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNoaWxkUm93U3BhbnMgPSBbXTtcbiAgICAgICAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyhoZWFkZXIuc3ViSGVhZGVycykuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY29sU3BhbjogY2hpbGRDb2xTcGFuLFxuICAgICAgICAgICAgcm93U3BhbjogY2hpbGRSb3dTcGFuXG4gICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgY29sU3BhbiArPSBjaGlsZENvbFNwYW47XG4gICAgICAgICAgY2hpbGRSb3dTcGFucy5wdXNoKGNoaWxkUm93U3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sU3BhbiA9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBtaW5DaGlsZFJvd1NwYW4gPSBNYXRoLm1pbiguLi5jaGlsZFJvd1NwYW5zKTtcbiAgICAgIHJvd1NwYW4gPSByb3dTcGFuICsgbWluQ2hpbGRSb3dTcGFuO1xuICAgICAgaGVhZGVyLmNvbFNwYW4gPSBjb2xTcGFuO1xuICAgICAgaGVhZGVyLnJvd1NwYW4gPSByb3dTcGFuO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sU3BhbixcbiAgICAgICAgcm93U3BhblxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucygoX2hlYWRlckdyb3VwcyQwJGhlYWRlID0gKF9oZWFkZXJHcm91cHMkID0gaGVhZGVyR3JvdXBzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlckdyb3VwcyQuaGVhZGVycykgIT0gbnVsbCA/IF9oZWFkZXJHcm91cHMkMCRoZWFkZSA6IFtdKTtcbiAgcmV0dXJuIGhlYWRlckdyb3Vwcztcbn1cblxuY29uc3QgY3JlYXRlUm93ID0gKHRhYmxlLCBpZCwgb3JpZ2luYWwsIHJvd0luZGV4LCBkZXB0aCwgc3ViUm93cywgcGFyZW50SWQpID0+IHtcbiAgbGV0IHJvdyA9IHtcbiAgICBpZCxcbiAgICBpbmRleDogcm93SW5kZXgsXG4gICAgb3JpZ2luYWwsXG4gICAgZGVwdGgsXG4gICAgcGFyZW50SWQsXG4gICAgX3ZhbHVlc0NhY2hlOiB7fSxcbiAgICBfdW5pcXVlVmFsdWVzQ2FjaGU6IHt9LFxuICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uYWNjZXNzb3JGbihyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcbiAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9LFxuICAgIGdldFVuaXF1ZVZhbHVlczogY29sdW1uSWQgPT4ge1xuICAgICAgaWYgKHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uYWNjZXNzb3JGbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBbcm93LmdldFZhbHVlKGNvbHVtbklkKV07XG4gICAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMocm93Lm9yaWdpbmFsLCByb3dJbmRleCk7XG4gICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfSxcbiAgICByZW5kZXJWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgdmFyIF9yb3ckZ2V0VmFsdWU7XG4gICAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsID8gX3JvdyRnZXRWYWx1ZSA6IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgICB9LFxuICAgIHN1YlJvd3M6IHN1YlJvd3MgIT0gbnVsbCA/IHN1YlJvd3MgOiBbXSxcbiAgICBnZXRMZWFmUm93czogKCkgPT4gZmxhdHRlbkJ5KHJvdy5zdWJSb3dzLCBkID0+IGQuc3ViUm93cyksXG4gICAgZ2V0UGFyZW50Um93OiAoKSA9PiByb3cucGFyZW50SWQgPyB0YWJsZS5nZXRSb3cocm93LnBhcmVudElkLCB0cnVlKSA6IHVuZGVmaW5lZCxcbiAgICBnZXRQYXJlbnRSb3dzOiAoKSA9PiB7XG4gICAgICBsZXQgcGFyZW50Um93cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3cgPSBjdXJyZW50Um93LmdldFBhcmVudFJvdygpO1xuICAgICAgICBpZiAoIXBhcmVudFJvdykgYnJlYWs7XG4gICAgICAgIHBhcmVudFJvd3MucHVzaChwYXJlbnRSb3cpO1xuICAgICAgICBjdXJyZW50Um93ID0gcGFyZW50Um93O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudFJvd3MucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgZ2V0QWxsQ2VsbHM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCldLCBsZWFmQ29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDZWxsKHRhYmxlLCByb3csIGNvbHVtbiwgY29sdW1uLmlkKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0QWxsQ2VsbHMnKSksXG4gICAgX2dldEFsbENlbGxzQnlDb2x1bW5JZDogbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCldLCBhbGxDZWxscyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ2VsbHMucmVkdWNlKChhY2MsIGNlbGwpID0+IHtcbiAgICAgICAgYWNjW2NlbGwuY29sdW1uLmlkXSA9IGNlbGw7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRBbGxDZWxsc0J5Q29sdW1uSWQnKSlcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGFibGUuX2ZlYXR1cmVzW2ldO1xuICAgIGZlYXR1cmUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVJvdyA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlUm93KHJvdywgdGFibGUpO1xuICB9XG4gIHJldHVybiByb3c7XG59O1xuXG4vL1xuXG5jb25zdCBDb2x1bW5GYWNldGluZyA9IHtcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwodGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gICAgY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkTWluTWF4VmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKTtcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBpbmNsdWRlc1N0cmluZyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX2ZpbHRlclZhbHVlJHRvU3RyaW5nLCBfcm93JGdldFZhbHVlO1xuICBjb25zdCBzZWFyY2ggPSBmaWx0ZXJWYWx1ZSA9PSBudWxsIHx8IChfZmlsdGVyVmFsdWUkdG9TdHJpbmcgPSBmaWx0ZXJWYWx1ZS50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX2ZpbHRlclZhbHVlJHRvU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBCb29sZWFuKChfcm93JGdldFZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZSA9IF9yb3ckZ2V0VmFsdWUudG9TdHJpbmcoKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZSA9IF9yb3ckZ2V0VmFsdWUudG9Mb3dlckNhc2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUuaW5jbHVkZXMoc2VhcmNoKSk7XG59O1xuaW5jbHVkZXNTdHJpbmcuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBpbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTI7XG4gIHJldHVybiBCb29sZWFuKChfcm93JGdldFZhbHVlMiA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUyID0gX3JvdyRnZXRWYWx1ZTIudG9TdHJpbmcoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUyLmluY2x1ZGVzKGZpbHRlclZhbHVlKSk7XG59O1xuaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBlcXVhbHNTdHJpbmcgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWUzO1xuICByZXR1cm4gKChfcm93JGdldFZhbHVlMyA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUzID0gX3JvdyRnZXRWYWx1ZTMudG9TdHJpbmcoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUzLnRvTG93ZXJDYXNlKCkpID09PSAoZmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbHRlclZhbHVlLnRvTG93ZXJDYXNlKCkpO1xufTtcbmVxdWFsc1N0cmluZy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGFyckluY2x1ZGVzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlNDtcbiAgcmV0dXJuIChfcm93JGdldFZhbHVlNCA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlNC5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSk7XG59O1xuYXJySW5jbHVkZXMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGFyckluY2x1ZGVzQWxsID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiAhZmlsdGVyVmFsdWUuc29tZSh2YWwgPT4ge1xuICAgIHZhciBfcm93JGdldFZhbHVlNTtcbiAgICByZXR1cm4gISgoX3JvdyRnZXRWYWx1ZTUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsICYmIF9yb3ckZ2V0VmFsdWU1LmluY2x1ZGVzKHZhbCkpO1xuICB9KTtcbn07XG5hcnJJbmNsdWRlc0FsbC5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgYXJySW5jbHVkZXNTb21lID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiBmaWx0ZXJWYWx1ZS5zb21lKHZhbCA9PiB7XG4gICAgdmFyIF9yb3ckZ2V0VmFsdWU2O1xuICAgIHJldHVybiAoX3JvdyRnZXRWYWx1ZTYgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTYuaW5jbHVkZXModmFsKTtcbiAgfSk7XG59O1xuYXJySW5jbHVkZXNTb21lLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBlcXVhbHMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkgPT09IGZpbHRlclZhbHVlO1xufTtcbmVxdWFscy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IHdlYWtFcXVhbHMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkgPT0gZmlsdGVyVmFsdWU7XG59O1xud2Vha0VxdWFscy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGluTnVtYmVyUmFuZ2UgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgbGV0IFttaW4sIG1heF0gPSBmaWx0ZXJWYWx1ZTtcbiAgY29uc3Qgcm93VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICByZXR1cm4gcm93VmFsdWUgPj0gbWluICYmIHJvd1ZhbHVlIDw9IG1heDtcbn07XG5pbk51bWJlclJhbmdlLnJlc29sdmVGaWx0ZXJWYWx1ZSA9IHZhbCA9PiB7XG4gIGxldCBbdW5zYWZlTWluLCB1bnNhZmVNYXhdID0gdmFsO1xuICBsZXQgcGFyc2VkTWluID0gdHlwZW9mIHVuc2FmZU1pbiAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHVuc2FmZU1pbikgOiB1bnNhZmVNaW47XG4gIGxldCBwYXJzZWRNYXggPSB0eXBlb2YgdW5zYWZlTWF4ICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQodW5zYWZlTWF4KSA6IHVuc2FmZU1heDtcbiAgbGV0IG1pbiA9IHVuc2FmZU1pbiA9PT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocGFyc2VkTWluKSA/IC1JbmZpbml0eSA6IHBhcnNlZE1pbjtcbiAgbGV0IG1heCA9IHVuc2FmZU1heCA9PT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocGFyc2VkTWF4KSA/IEluZmluaXR5IDogcGFyc2VkTWF4O1xuICBpZiAobWluID4gbWF4KSB7XG4gICAgY29uc3QgdGVtcCA9IG1pbjtcbiAgICBtaW4gPSBtYXg7XG4gICAgbWF4ID0gdGVtcDtcbiAgfVxuICByZXR1cm4gW21pbiwgbWF4XTtcbn07XG5pbk51bWJlclJhbmdlLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8IHRlc3RGYWxzZXkodmFsWzBdKSAmJiB0ZXN0RmFsc2V5KHZhbFsxXSk7XG5cbi8vIEV4cG9ydFxuXG5jb25zdCBmaWx0ZXJGbnMgPSB7XG4gIGluY2x1ZGVzU3RyaW5nLFxuICBpbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZSxcbiAgZXF1YWxzU3RyaW5nLFxuICBhcnJJbmNsdWRlcyxcbiAgYXJySW5jbHVkZXNBbGwsXG4gIGFyckluY2x1ZGVzU29tZSxcbiAgZXF1YWxzLFxuICB3ZWFrRXF1YWxzLFxuICBpbk51bWJlclJhbmdlXG59O1xuLy8gVXRpbHNcblxuZnVuY3Rpb24gdGVzdEZhbHNleSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09ICcnO1xufVxuXG4vL1xuXG5jb25zdCBDb2x1bW5GaWx0ZXJpbmcgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsdGVyRm46ICdhdXRvJ1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5GaWx0ZXJzOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5GaWx0ZXJzQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5GaWx0ZXJzJywgdGFibGUpLFxuICAgICAgZmlsdGVyRnJvbUxlYWZSb3dzOiBmYWxzZSxcbiAgICAgIG1heExlYWZSb3dGaWx0ZXJEZXB0aDogMTAwXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluTnVtYmVyUmFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmVxdWFscztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmFyckluY2x1ZGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbHRlckZucy53ZWFrRXF1YWxzO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGZpbHRlciwgX3RhYmxlJG9wdGlvbnMkZmlsdGVyMjtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4pID8gY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbiA6IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4oKSA6IC8vIEB0cy1pZ25vcmVcbiAgICAgIChfdGFibGUkb3B0aW9ucyRmaWx0ZXIgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyMltjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlciA6IGZpbHRlckZuc1tjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuXTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5GaWx0ZXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUNvbHVtbkZpbHRlcikgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVGaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNGaWx0ZXJlZCA9ICgpID0+IGNvbHVtbi5nZXRGaWx0ZXJJbmRleCgpID4gLTE7XG4gICAgY29sdW1uLmdldEZpbHRlclZhbHVlID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSBfdGFibGUkZ2V0U3RhdGUkY29sdW0uZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0udmFsdWU7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0RmlsdGVySW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtMiwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMztcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0zID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtMy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA6IC0xO1xuICAgIH07XG4gICAgY29sdW1uLnNldEZpbHRlclZhbHVlID0gdmFsdWUgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uRmlsdGVycyhvbGQgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgICBjb25zdCBwcmV2aW91c0ZpbHRlciA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBjb25zdCBuZXdGaWx0ZXIgPSBmdW5jdGlvbmFsVXBkYXRlKHZhbHVlLCBwcmV2aW91c0ZpbHRlciA/IHByZXZpb3VzRmlsdGVyLnZhbHVlIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAvL1xuICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgbmV3RmlsdGVyLCBjb2x1bW4pKSB7XG4gICAgICAgICAgdmFyIF9vbGQkZmlsdGVyO1xuICAgICAgICAgIHJldHVybiAoX29sZCRmaWx0ZXIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX29sZCRmaWx0ZXIgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJPYmogPSB7XG4gICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICB2YWx1ZTogbmV3RmlsdGVyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcmV2aW91c0ZpbHRlcikge1xuICAgICAgICAgIHZhciBfb2xkJG1hcDtcbiAgICAgICAgICByZXR1cm4gKF9vbGQkbWFwID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubWFwKGQgPT4ge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3RmlsdGVyT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSkpICE9IG51bGwgPyBfb2xkJG1hcCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5vbGQsIG5ld0ZpbHRlck9ial07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtuZXdGaWx0ZXJPYmpdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCBfdGFibGUpID0+IHtcbiAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9O1xuICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YSA9IHt9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMgPSB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZUZuID0gb2xkID0+IHtcbiAgICAgICAgdmFyIF9mdW5jdGlvbmFsVXBkYXRlO1xuICAgICAgICByZXR1cm4gKF9mdW5jdGlvbmFsVXBkYXRlID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQpKSA9PSBudWxsID8gdm9pZCAwIDogX2Z1bmN0aW9uYWxVcGRhdGUuZmlsdGVyKGZpbHRlciA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGZpbHRlci5pZCk7XG4gICAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCBmaWx0ZXIudmFsdWUsIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGFibGUub3B0aW9ucy5vbkNvbHVtbkZpbHRlcnNDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSh1cGRhdGVGbik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldENvbHVtbkZpbHRlcnMgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmNvbHVtbkZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCB2YWx1ZSwgY29sdW1uKSB7XG4gIHJldHVybiAoZmlsdGVyRm4gJiYgZmlsdGVyRm4uYXV0b1JlbW92ZSA/IGZpbHRlckZuLmF1dG9SZW1vdmUodmFsdWUsIGNvbHVtbikgOiBmYWxzZSkgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICF2YWx1ZTtcbn1cblxuY29uc3Qgc3VtID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICAvLyBJdCdzIGZhc3RlciB0byBqdXN0IGFkZCB0aGUgYWdncmVnYXRpb25zIHRvZ2V0aGVyIGluc3RlYWQgb2ZcbiAgLy8gcHJvY2VzcyBsZWFmIG5vZGVzIGluZGl2aWR1YWxseVxuICByZXR1cm4gY2hpbGRSb3dzLnJlZHVjZSgoc3VtLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dC5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgcmV0dXJuIHN1bSArICh0eXBlb2YgbmV4dFZhbHVlID09PSAnbnVtYmVyJyA/IG5leHRWYWx1ZSA6IDApO1xuICB9LCAwKTtcbn07XG5jb25zdCBtaW4gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtaW47XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtaW4gPiB2YWx1ZSB8fCBtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpIHtcbiAgICAgIG1pbiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtaW47XG59O1xuY29uc3QgbWF4ID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWF4O1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWF4IDwgdmFsdWUgfHwgbWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XG4gICAgICBtYXggPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF4O1xufTtcbmNvbnN0IGV4dGVudCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1heDtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW21pbiwgbWF4XTtcbn07XG5jb25zdCBtZWFuID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3VtID0gMDtcbiAgbGVhZlJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGxldCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgKytjb3VudCwgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChjb3VudCkgcmV0dXJuIHN1bSAvIGNvdW50O1xuICByZXR1cm47XG59O1xuY29uc3QgbWVkaWFuID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICBpZiAoIWxlYWZSb3dzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBsZWFmUm93cy5tYXAocm93ID0+IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpO1xuICBpZiAoIWlzTnVtYmVyQXJyYXkodmFsdWVzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZXNbMF07XG4gIH1cbiAgY29uc3QgbWlkID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gIGNvbnN0IG51bXMgPSB2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICByZXR1cm4gdmFsdWVzLmxlbmd0aCAlIDIgIT09IDAgPyBudW1zW21pZF0gOiAobnVtc1ttaWQgLSAxXSArIG51bXNbbWlkXSkgLyAyO1xufTtcbmNvbnN0IHVuaXF1ZSA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnZhbHVlcygpKTtcbn07XG5jb25zdCB1bmlxdWVDb3VudCA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIG5ldyBTZXQobGVhZlJvd3MubWFwKGQgPT4gZC5nZXRWYWx1ZShjb2x1bW5JZCkpKS5zaXplO1xufTtcbmNvbnN0IGNvdW50ID0gKF9jb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIGxlYWZSb3dzLmxlbmd0aDtcbn07XG5jb25zdCBhZ2dyZWdhdGlvbkZucyA9IHtcbiAgc3VtLFxuICBtaW4sXG4gIG1heCxcbiAgZXh0ZW50LFxuICBtZWFuLFxuICBtZWRpYW4sXG4gIHVuaXF1ZSxcbiAgdW5pcXVlQ291bnQsXG4gIGNvdW50XG59O1xuXG4vL1xuXG5jb25zdCBDb2x1bW5Hcm91cGluZyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBhZ2dyZWdhdGVkQ2VsbDogcHJvcHMgPT4ge1xuICAgICAgICB2YXIgX3RvU3RyaW5nLCBfcHJvcHMkZ2V0VmFsdWU7XG4gICAgICAgIHJldHVybiAoX3RvU3RyaW5nID0gKF9wcm9wcyRnZXRWYWx1ZSA9IHByb3BzLmdldFZhbHVlKCkpID09IG51bGwgfHwgX3Byb3BzJGdldFZhbHVlLnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ2V0VmFsdWUudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF90b1N0cmluZyA6IG51bGw7XG4gICAgICB9LFxuICAgICAgYWdncmVnYXRpb25GbjogJ2F1dG8nXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdyb3VwaW5nOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Hcm91cGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ3JvdXBpbmcnLCB0YWJsZSksXG4gICAgICBncm91cGVkQ29sdW1uTW9kZTogJ3Jlb3JkZXInXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi50b2dnbGVHcm91cGluZyA9ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldEdyb3VwaW5nKG9sZCA9PiB7XG4gICAgICAgIC8vIEZpbmQgYW55IGV4aXN0aW5nIGdyb3VwaW5nIGZvciB0aGlzIGNvbHVtblxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmluY2x1ZGVzKGNvbHVtbi5pZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi4ob2xkICE9IG51bGwgPyBvbGQgOiBbXSksIGNvbHVtbi5pZF07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5Hcm91cCA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR3JvdXBpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAoISFjb2x1bW4uYWNjZXNzb3JGbiB8fCAhIWNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNHcm91cGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRncm91cDtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cC5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgIH07XG4gICAgY29sdW1uLmdldEdyb3VwZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cDIuaW5kZXhPZihjb2x1bW4uaWQpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZUdyb3VwaW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkdyb3VwID0gY29sdW1uLmdldENhbkdyb3VwKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbkdyb3VwKSByZXR1cm47XG4gICAgICAgIGNvbHVtbi50b2dnbGVHcm91cGluZygpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uRm5zLnN1bTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uRm5zLmV4dGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGFnZ3JlZywgX3RhYmxlJG9wdGlvbnMkYWdncmVnMjtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA6IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9BZ2dyZWdhdGlvbkZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkYWdncmVnID0gKF90YWJsZSRvcHRpb25zJGFnZ3JlZzIgPSB0YWJsZS5vcHRpb25zLmFnZ3JlZ2F0aW9uRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkYWdncmVnMltjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYWdncmVnIDogYWdncmVnYXRpb25GbnNbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldEdyb3VwaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Hcm91cGluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldEdyb3VwaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGcsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRHcm91cGluZyhkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGcgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuZ3JvdXBpbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGcgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0R3JvdXBlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxHcm91cGluZyB8fCAhdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuZ2V0SXNHcm91cGVkID0gKCkgPT4gISFyb3cuZ3JvdXBpbmdDb2x1bW5JZDtcbiAgICByb3cuZ2V0R3JvdXBpbmdWYWx1ZSA9IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgICB9XG4gICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRHcm91cGluZ1ZhbHVlKHJvdy5vcmlnaW5hbCk7XG4gICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9O1xuICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZSA9IHt9O1xuICB9LFxuICBjcmVhdGVDZWxsOiAoY2VsbCwgY29sdW1uLCByb3csIHRhYmxlKSA9PiB7XG4gICAgY2VsbC5nZXRJc0dyb3VwZWQgPSAoKSA9PiBjb2x1bW4uZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmlkID09PSByb3cuZ3JvdXBpbmdDb2x1bW5JZDtcbiAgICBjZWxsLmdldElzUGxhY2Vob2xkZXIgPSAoKSA9PiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiBjb2x1bW4uZ2V0SXNHcm91cGVkKCk7XG4gICAgY2VsbC5nZXRJc0FnZ3JlZ2F0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgICAgcmV0dXJuICFjZWxsLmdldElzR3JvdXBlZCgpICYmICFjZWxsLmdldElzUGxhY2Vob2xkZXIoKSAmJiAhISgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gIGlmICghKGdyb3VwaW5nICE9IG51bGwgJiYgZ3JvdXBpbmcubGVuZ3RoKSB8fCAhZ3JvdXBlZENvbHVtbk1vZGUpIHtcbiAgICByZXR1cm4gbGVhZkNvbHVtbnM7XG4gIH1cbiAgY29uc3Qgbm9uR3JvdXBpbmdDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbCA9PiAhZ3JvdXBpbmcuaW5jbHVkZXMoY29sLmlkKSk7XG4gIGlmIChncm91cGVkQ29sdW1uTW9kZSA9PT0gJ3JlbW92ZScpIHtcbiAgICByZXR1cm4gbm9uR3JvdXBpbmdDb2x1bW5zO1xuICB9XG4gIGNvbnN0IGdyb3VwaW5nQ29sdW1ucyA9IGdyb3VwaW5nLm1hcChnID0+IGxlYWZDb2x1bW5zLmZpbmQoY29sID0+IGNvbC5pZCA9PT0gZykpLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIFsuLi5ncm91cGluZ0NvbHVtbnMsIC4uLm5vbkdyb3VwaW5nQ29sdW1uc107XG59XG5cbi8vXG5cbmNvbnN0IENvbHVtbk9yZGVyaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uT3JkZXI6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtbk9yZGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5PcmRlcicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0SW5kZXggPSBtZW1vKHBvc2l0aW9uID0+IFtfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbildLCBjb2x1bW5zID0+IGNvbHVtbnMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRJbmRleCcpKTtcbiAgICBjb2x1bW4uZ2V0SXNGaXJzdENvbHVtbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfY29sdW1ucyQ7XG4gICAgICBjb25zdCBjb2x1bW5zID0gX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbnMkID0gY29sdW1uc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb2x1bW5zJC5pZCkgPT09IGNvbHVtbi5pZDtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc0xhc3RDb2x1bW4gPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX2NvbHVtbnM7XG4gICAgICBjb25zdCBjb2x1bW5zID0gX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbnMgPSBjb2x1bW5zW2NvbHVtbnMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1ucy5pZCkgPT09IGNvbHVtbi5pZDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtbk9yZGVyID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtbk9yZGVyID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5PcmRlcihkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uT3JkZXIpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4gPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbk9yZGVyLCB0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5vcHRpb25zLmdyb3VwZWRDb2x1bW5Nb2RlXSwgKGNvbHVtbk9yZGVyLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpID0+IGNvbHVtbnMgPT4ge1xuICAgICAgLy8gU29ydCBncm91cGVkIGNvbHVtbnMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb2x1bW4gbGlzdFxuICAgICAgLy8gYmVmb3JlIHRoZSBoZWFkZXJzIGFyZSBidWlsdFxuICAgICAgbGV0IG9yZGVyZWRDb2x1bW5zID0gW107XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG9yZGVyLCByZXR1cm4gdGhlIG5vcm1hbCBjb2x1bW5zXG4gICAgICBpZiAoIShjb2x1bW5PcmRlciAhPSBudWxsICYmIGNvbHVtbk9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sdW1uT3JkZXJDb3B5ID0gWy4uLmNvbHVtbk9yZGVyXTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmRlciwgbWFrZSBhIGNvcHkgb2YgdGhlIGNvbHVtbnNcbiAgICAgICAgY29uc3QgY29sdW1uc0NvcHkgPSBbLi4uY29sdW1uc107XG5cbiAgICAgICAgLy8gQW5kIG1ha2UgYSBuZXcgb3JkZXJlZCBhcnJheSBvZiB0aGUgY29sdW1uc1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgY29sdW1ucyBhbmQgcGxhY2UgdGhlbSBpbiBvcmRlciBpbnRvIHRoZSBuZXcgYXJyYXlcbiAgICAgICAgd2hpbGUgKGNvbHVtbnNDb3B5Lmxlbmd0aCAmJiBjb2x1bW5PcmRlckNvcHkubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uSWQgPSBjb2x1bW5PcmRlckNvcHkuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZEluZGV4ID0gY29sdW1uc0NvcHkuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gdGFyZ2V0Q29sdW1uSWQpO1xuICAgICAgICAgIGlmIChmb3VuZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIG9yZGVyZWRDb2x1bW5zLnB1c2goY29sdW1uc0NvcHkuc3BsaWNlKGZvdW5kSW5kZXgsIDEpWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGNvbHVtbnMgbGVmdCwgYWRkIHRoZW0gdG8gdGhlIGVuZFxuICAgICAgICBvcmRlcmVkQ29sdW1ucyA9IFsuLi5vcmRlcmVkQ29sdW1ucywgLi4uY29sdW1uc0NvcHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhvcmRlcmVkQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdfZ2V0T3JkZXJDb2x1bW5zRm4nKSk7XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICBsZWZ0OiBbXSxcbiAgcmlnaHQ6IFtdXG59KTtcbmNvbnN0IENvbHVtblBpbm5pbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5QaW5uaW5nOiBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uUGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uUGlubmluZycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4ucGluID0gcG9zaXRpb24gPT4ge1xuICAgICAgY29uc3QgY29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyhvbGQgPT4ge1xuICAgICAgICB2YXIgX29sZCRsZWZ0MywgX29sZCRyaWdodDM7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHZhciBfb2xkJGxlZnQsIF9vbGQkcmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6ICgoX29sZCRsZWZ0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdCA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLFxuICAgICAgICAgICAgcmlnaHQ6IFsuLi4oKF9vbGQkcmlnaHQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0MiwgX29sZCRyaWdodDI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IFsuLi4oKF9vbGQkbGVmdDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0MiA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLCAuLi5jb2x1bW5JZHNdLFxuICAgICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQyIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogKChfb2xkJGxlZnQzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDMgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSxcbiAgICAgICAgICByaWdodDogKChfb2xkJHJpZ2h0MyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnJpZ2h0KSAhPSBudWxsID8gX29sZCRyaWdodDMgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuUGluID0gKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbnMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKTtcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5zb21lKGQgPT4ge1xuICAgICAgICB2YXIgX2QkY29sdW1uRGVmJGVuYWJsZVBpLCBfcmVmLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICAgIHJldHVybiAoKF9kJGNvbHVtbkRlZiRlbmFibGVQaSA9IGQuY29sdW1uRGVmLmVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfZCRjb2x1bW5EZWYkZW5hYmxlUGkgOiB0cnVlKSAmJiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5QaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdGFibGUub3B0aW9ucy5lbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZiA6IHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNQaW5uZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xuICAgICAgY29uc3QgaXNMZWZ0ID0gbGVhZkNvbHVtbklkcy5zb21lKGQgPT4gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5pbmNsdWRlcyhkKSk7XG4gICAgICBjb25zdCBpc1JpZ2h0ID0gbGVhZkNvbHVtbklkcy5zb21lKGQgPT4gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0LmluY2x1ZGVzKGQpKTtcbiAgICAgIHJldHVybiBpc0xlZnQgPyAnbGVmdCcgOiBpc1JpZ2h0ID8gJ3JpZ2h0JyA6IGZhbHNlO1xuICAgIH07XG4gICAgY29sdW1uLmdldFBpbm5lZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bSwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gY29sdW1uLmdldElzUGlubmVkKCk7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPyAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcpID09IG51bGwgfHwgKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSBfdGFibGUkZ2V0U3RhdGUkY29sdW0yW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIuaW5kZXhPZihjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtIDogLTEgOiAwO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDZWxscywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRBbmRSaWdodCA9IFsuLi4obGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKSwgLi4uKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKV07XG4gICAgICByZXR1cm4gYWxsQ2VsbHMuZmlsdGVyKGQgPT4gIWxlZnRBbmRSaWdodC5pbmNsdWRlcyhkLmNvbHVtbi5pZCkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0Q2VudGVyVmlzaWJsZUNlbGxzJykpO1xuICAgIHJvdy5nZXRMZWZ0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ2VsbHMsIGxlZnQpID0+IHtcbiAgICAgIGNvbnN0IGNlbGxzID0gKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENlbGxzLmZpbmQoY2VsbCA9PiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb246ICdsZWZ0J1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0TGVmdFZpc2libGVDZWxscycpKTtcbiAgICByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ2VsbHMsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBjZWxscyA9IChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENlbGxzLmZpbmQoY2VsbCA9PiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb246ICdyaWdodCdcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldFJpZ2h0VmlzaWJsZUNlbGxzJykpO1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uUGlubmluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblBpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuY29sdW1uUGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zUGlubmVkID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9waW5uaW5nU3RhdGUkcG9zaXRpbztcbiAgICAgIGNvbnN0IHBpbm5pbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9waW5uaW5nU3RhdGUkbGVmdCwgX3Bpbm5pbmdTdGF0ZSRyaWdodDtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKChfcGlubmluZ1N0YXRlJGxlZnQgPSBwaW5uaW5nU3RhdGUubGVmdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkbGVmdC5sZW5ndGgpIHx8ICgoX3Bpbm5pbmdTdGF0ZSRyaWdodCA9IHBpbm5pbmdTdGF0ZS5yaWdodCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcmlnaHQubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQm9vbGVhbigoX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvID0gcGlubmluZ1N0YXRlW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcG9zaXRpby5sZW5ndGgpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0TGVmdExlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVmdCkgPT4ge1xuICAgICAgcmV0dXJuIChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRMZWZ0TGVhZkNvbHVtbnMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENvbHVtbnMuZmluZChjb2x1bW4gPT4gY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldFJpZ2h0TGVhZkNvbHVtbnMnKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyTGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBsZWZ0QW5kUmlnaHQgPSBbLi4uKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSksIC4uLihyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSldO1xuICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmlsdGVyKGQgPT4gIWxlZnRBbmRSaWdodC5pbmNsdWRlcyhkLmlkKSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRDZW50ZXJMZWFmQ29sdW1ucycpKTtcbiAgfVxufTtcblxuLy9cblxuLy9cblxuY29uc3QgZGVmYXVsdENvbHVtblNpemluZyA9IHtcbiAgc2l6ZTogMTUwLFxuICBtaW5TaXplOiAyMCxcbiAgbWF4U2l6ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbn07XG5jb25zdCBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlID0gKCkgPT4gKHtcbiAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gIHN0YXJ0U2l6ZTogbnVsbCxcbiAgZGVsdGFPZmZzZXQ6IG51bGwsXG4gIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcbiAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gIGNvbHVtblNpemluZ1N0YXJ0OiBbXVxufSk7XG5jb25zdCBDb2x1bW5TaXppbmcgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4gZGVmYXVsdENvbHVtblNpemluZztcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblNpemluZzoge30sXG4gICAgICBjb2x1bW5TaXppbmdJbmZvOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblJlc2l6ZU1vZGU6ICdvbkVuZCcsXG4gICAgICBjb2x1bW5SZXNpemVEaXJlY3Rpb246ICdsdHInLFxuICAgICAgb25Db2x1bW5TaXppbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZycsIHRhYmxlKSxcbiAgICAgIG9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nSW5mbycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRtaW4sIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJG1heDtcbiAgICAgIGNvbnN0IGNvbHVtblNpemUgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ1tjb2x1bW4uaWRdO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KChfY29sdW1uJGNvbHVtbkRlZiRtaW4gPSBjb2x1bW4uY29sdW1uRGVmLm1pblNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtaW4gOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1pblNpemUsIChfcmVmID0gY29sdW1uU2l6ZSAhPSBudWxsID8gY29sdW1uU2l6ZSA6IGNvbHVtbi5jb2x1bW5EZWYuc2l6ZSkgIT0gbnVsbCA/IF9yZWYgOiBkZWZhdWx0Q29sdW1uU2l6aW5nLnNpemUpLCAoX2NvbHVtbiRjb2x1bW5EZWYkbWF4ID0gY29sdW1uLmNvbHVtbkRlZi5tYXhTaXplKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkbWF4IDogZGVmYXVsdENvbHVtblNpemluZy5tYXhTaXplKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTdGFydCA9IG1lbW8ocG9zaXRpb24gPT4gW3Bvc2l0aW9uLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbiksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nXSwgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PiBjb2x1bW5zLnNsaWNlKDAsIGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikpLnJlZHVjZSgoc3VtLCBjb2x1bW4pID0+IHN1bSArIGNvbHVtbi5nZXRTaXplKCksIDApLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldFN0YXJ0JykpO1xuICAgIGNvbHVtbi5nZXRBZnRlciA9IG1lbW8ocG9zaXRpb24gPT4gW3Bvc2l0aW9uLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbiksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nXSwgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PiBjb2x1bW5zLnNsaWNlKGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikgKyAxKS5yZWR1Y2UoKHN1bSwgY29sdW1uKSA9PiBzdW0gKyBjb2x1bW4uZ2V0U2l6ZSgpLCAwKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBZnRlcicpKTtcbiAgICBjb2x1bW4ucmVzZXRTaXplID0gKCkgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBbY29sdW1uLmlkXTogXyxcbiAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5SZXNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVJlc2l6aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNSZXNpemluZyA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ0luZm8uaXNSZXNpemluZ0NvbHVtbiA9PT0gY29sdW1uLmlkO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUhlYWRlcjogKGhlYWRlciwgdGFibGUpID0+IHtcbiAgICBoZWFkZXIuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgY29uc3QgcmVjdXJzZSA9IGhlYWRlciA9PiB7XG4gICAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5mb3JFYWNoKHJlY3Vyc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfaGVhZGVyJGNvbHVtbiRnZXRTaXo7XG4gICAgICAgICAgc3VtICs9IChfaGVhZGVyJGNvbHVtbiRnZXRTaXogPSBoZWFkZXIuY29sdW1uLmdldFNpemUoKSkgIT0gbnVsbCA/IF9oZWFkZXIkY29sdW1uJGdldFNpeiA6IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWN1cnNlKGhlYWRlcik7XG4gICAgICByZXR1cm4gc3VtO1xuICAgIH07XG4gICAgaGVhZGVyLmdldFN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYgKGhlYWRlci5pbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmdIZWFkZXIgPSBoZWFkZXIuaGVhZGVyR3JvdXAuaGVhZGVyc1toZWFkZXIuaW5kZXggLSAxXTtcbiAgICAgICAgcmV0dXJuIHByZXZTaWJsaW5nSGVhZGVyLmdldFN0YXJ0KCkgKyBwcmV2U2libGluZ0hlYWRlci5nZXRTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGhlYWRlci5nZXRSZXNpemVIYW5kbGVyID0gX2NvbnRleHREb2N1bWVudCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oaGVhZGVyLmNvbHVtbi5pZCk7XG4gICAgICBjb25zdCBjYW5SZXNpemUgPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRDYW5SZXNpemUoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgaWYgKCFjb2x1bW4gfHwgIWNhblJlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgLy8gbGV0cyBub3QgcmVzcG9uZCB0byBtdWx0aXBsZSB0b3VjaGVzIChlLmcuIDIgb3IgMyBmaW5nZXJzKVxuICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTaXplID0gaGVhZGVyLmdldFNpemUoKTtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6aW5nU3RhcnQgPSBoZWFkZXIgPyBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKS5tYXAoZCA9PiBbZC5jb2x1bW4uaWQsIGQuY29sdW1uLmdldFNpemUoKV0pIDogW1tjb2x1bW4uaWQsIGNvbHVtbi5nZXRTaXplKCldXTtcbiAgICAgICAgY29uc3QgY2xpZW50WCA9IGlzVG91Y2hTdGFydEV2ZW50KGUpID8gTWF0aC5yb3VuZChlLnRvdWNoZXNbMF0uY2xpZW50WCkgOiBlLmNsaWVudFg7XG4gICAgICAgIGNvbnN0IG5ld0NvbHVtblNpemluZyA9IHt9O1xuICAgICAgICBjb25zdCB1cGRhdGVPZmZzZXQgPSAoZXZlbnRUeXBlLCBjbGllbnRYUG9zKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnRYUG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiB7XG4gICAgICAgICAgICB2YXIgX29sZCRzdGFydE9mZnNldCwgX29sZCRzdGFydFNpemU7XG4gICAgICAgICAgICBjb25zdCBkZWx0YURpcmVjdGlvbiA9IHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gKGNsaWVudFhQb3MgLSAoKF9vbGQkc3RhcnRPZmZzZXQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5zdGFydE9mZnNldCkgIT0gbnVsbCA/IF9vbGQkc3RhcnRPZmZzZXQgOiAwKSkgKiBkZWx0YURpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhUGVyY2VudGFnZSA9IE1hdGgubWF4KGRlbHRhT2Zmc2V0IC8gKChfb2xkJHN0YXJ0U2l6ZSA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0U2l6ZSkgIT0gbnVsbCA/IF9vbGQkc3RhcnRTaXplIDogMCksIC0wLjk5OTk5OSk7XG4gICAgICAgICAgICBvbGQuY29sdW1uU2l6aW5nU3RhcnQuZm9yRWFjaChfcmVmMyA9PiB7XG4gICAgICAgICAgICAgIGxldCBbY29sdW1uSWQsIGhlYWRlclNpemVdID0gX3JlZjM7XG4gICAgICAgICAgICAgIG5ld0NvbHVtblNpemluZ1tjb2x1bW5JZF0gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGhlYWRlclNpemUgKyBoZWFkZXJTaXplICogZGVsdGFQZXJjZW50YWdlLCAwKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgICAgZGVsdGFPZmZzZXQsXG4gICAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGFibGUub3B0aW9ucy5jb2x1bW5SZXNpemVNb2RlID09PSAnb25DaGFuZ2UnIHx8IGV2ZW50VHlwZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhvbGQgPT4gKHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICAuLi5uZXdDb2x1bW5TaXppbmdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uTW92ZSA9IGNsaWVudFhQb3MgPT4gdXBkYXRlT2Zmc2V0KCdtb3ZlJywgY2xpZW50WFBvcyk7XG4gICAgICAgIGNvbnN0IG9uRW5kID0gY2xpZW50WFBvcyA9PiB7XG4gICAgICAgICAgdXBkYXRlT2Zmc2V0KCdlbmQnLCBjbGllbnRYUG9zKTtcbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiAoe1xuICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhT2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICAgICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0RG9jdW1lbnQgPSBfY29udGV4dERvY3VtZW50IHx8IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGw7XG4gICAgICAgIGNvbnN0IG1vdXNlRXZlbnRzID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiBlID0+IG9uTW92ZShlLmNsaWVudFgpLFxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VFdmVudHMubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIpO1xuICAgICAgICAgICAgb25FbmQoZS5jbGllbnRYKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvdWNoRXZlbnRzID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2UkdG91Y2hlcyQ7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2hFdmVudHMubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFdmVudHMudXBIYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FbmQoKF9lJHRvdWNoZXMkID0gZS50b3VjaGVzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2UkdG91Y2hlcyQuY2xpZW50WCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXNzaXZlSWZTdXBwb3J0ZWQgPSBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSA/IHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VFdmVudHMudXBIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBjbGllbnRYLFxuICAgICAgICAgIHN0YXJ0U2l6ZSxcbiAgICAgICAgICBkZWx0YU9mZnNldDogMCxcbiAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogY29sdW1uLmlkXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uU2l6aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0SGVhZGVyU2l6ZUluZm8gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYzI7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMyID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZ0luZm8pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMyIDogZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0SGVhZGVyR3JvdXAsIF90YWJsZSRnZXRIZWFkZXJHcm91cDI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRIZWFkZXJHcm91cCA9IChfdGFibGUkZ2V0SGVhZGVyR3JvdXAyID0gdGFibGUuZ2V0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0SGVhZGVyR3JvdXAyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldEhlYWRlckdyb3VwIDogMDtcbiAgICB9O1xuICAgIHRhYmxlLmdldExlZnRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldExlZnRIZWFkZXJHLCBfdGFibGUkZ2V0TGVmdEhlYWRlckcyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0TGVmdEhlYWRlckcgPSAoX3RhYmxlJGdldExlZnRIZWFkZXJHMiA9IHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRMZWZ0SGVhZGVyRzIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0TGVmdEhlYWRlckcgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2VudGVyVG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDZW50ZXJIZWFkZSwgX3RhYmxlJGdldENlbnRlckhlYWRlMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldENlbnRlckhlYWRlID0gKF90YWJsZSRnZXRDZW50ZXJIZWFkZTIgPSB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDZW50ZXJIZWFkZTIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0Q2VudGVySGVhZGUgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UmlnaHRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFJpZ2h0SGVhZGVyLCBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0UmlnaHRIZWFkZXIgPSAoX3RhYmxlJGdldFJpZ2h0SGVhZGVyMiA9IHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldFJpZ2h0SGVhZGVyIDogMDtcbiAgICB9O1xuICB9XG59O1xubGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBudWxsO1xuZnVuY3Rpb24gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHBhc3NpdmVTdXBwb3J0ZWQgPT09ICdib29sZWFuJykgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG5vb3AsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHBhc3NpdmVTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufVxuZnVuY3Rpb24gaXNUb3VjaFN0YXJ0RXZlbnQoZSkge1xuICByZXR1cm4gZS50eXBlID09PSAndG91Y2hzdGFydCc7XG59XG5cbi8vXG5cbmNvbnN0IENvbHVtblZpc2liaWxpdHkgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5WaXNpYmlsaXR5OiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5WaXNpYmlsaXR5JywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5ID0gdmFsdWUgPT4ge1xuICAgICAgaWYgKGNvbHVtbi5nZXRDYW5IaWRlKCkpIHtcbiAgICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShvbGQgPT4gKHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgW2NvbHVtbi5pZF06IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6ICFjb2x1bW4uZ2V0SXNWaXNpYmxlKClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29sdW1uLmdldElzVmlzaWJsZSA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkZ2V0U3RhdGUkY29sdW07XG4gICAgICBjb25zdCBjaGlsZENvbHVtbnMgPSBjb2x1bW4uY29sdW1ucztcbiAgICAgIHJldHVybiAoX3JlZiA9IGNoaWxkQ29sdW1ucy5sZW5ndGggPyBjaGlsZENvbHVtbnMuc29tZShjID0+IGMuZ2V0SXNWaXNpYmxlKCkpIDogKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bVtjb2x1bW4uaWRdKSAhPSBudWxsID8gX3JlZiA6IHRydWU7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuSGlkZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUhpZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eSA9PSBudWxsIHx8IGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5KGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuZ2V0QWxsQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5WaXNpYmlsaXR5XSwgY2VsbHMgPT4ge1xuICAgICAgcmV0dXJuIGNlbGxzLmZpbHRlcihjZWxsID0+IGNlbGwuY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ19nZXRBbGxWaXNpYmxlQ2VsbHMnKSk7XG4gICAgcm93LmdldFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5nZXRMZWZ0VmlzaWJsZUNlbGxzKCksIHJvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMoKSwgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzKCldLCAobGVmdCwgY2VudGVyLCByaWdodCkgPT4gWy4uLmxlZnQsIC4uLmNlbnRlciwgLi4ucmlnaHRdLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldFZpc2libGVDZWxscycpKTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICBjb25zdCBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QgPSAoa2V5LCBnZXRDb2x1bW5zKSA9PiB7XG4gICAgICByZXR1cm4gbWVtbygoKSA9PiBbZ2V0Q29sdW1ucygpLCBnZXRDb2x1bW5zKCkuZmlsdGVyKGQgPT4gZC5nZXRJc1Zpc2libGUoKSkubWFwKGQgPT4gZC5pZCkuam9pbignXycpXSwgY29sdW1ucyA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBkLmdldElzVmlzaWJsZSgpKTtcbiAgICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCBrZXkpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFZpc2libGVGbGF0Q29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0VmlzaWJsZUZsYXRDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0TGVmdExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5ID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5WaXNpYmlsaXR5ID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5WaXNpYmlsaXR5KSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDoge30pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUgPSB2YWx1ZSA9PiB7XG4gICAgICB2YXIgX3ZhbHVlO1xuICAgICAgdmFsdWUgPSAoX3ZhbHVlID0gdmFsdWUpICE9IG51bGwgPyBfdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSgpO1xuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSh0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnJlZHVjZSgob2JqLCBjb2x1bW4pID0+ICh7XG4gICAgICAgIC4uLm9iaixcbiAgICAgICAgW2NvbHVtbi5pZF06ICF2YWx1ZSA/ICEoY29sdW1uLmdldENhbkhpZGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0Q2FuSGlkZSgpKSA6IHZhbHVlXG4gICAgICB9KSwge30pKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsQ29sdW1uc1Zpc2libGUgPSAoKSA9PiAhdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiAhKGNvbHVtbi5nZXRJc1Zpc2libGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpKTtcbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSA9ICgpID0+IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuc29tZShjb2x1bW4gPT4gY29sdW1uLmdldElzVmlzaWJsZSA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxDb2x1bW5zVmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSgoX3RhcmdldCA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKSB7XG4gIHJldHVybiAhcG9zaXRpb24gPyB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHBvc2l0aW9uID09PSAnY2VudGVyJyA/IHRhYmxlLmdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucygpIDogcG9zaXRpb24gPT09ICdsZWZ0JyA/IHRhYmxlLmdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zKCk7XG59XG5cbi8vXG5cbmNvbnN0IEdsb2JhbEZhY2V0aW5nID0ge1xuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcygpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IEdsb2JhbEZpbHRlcmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdsb2JhbEZpbHRlcjogdW5kZWZpbmVkLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkdsb2JhbEZpbHRlckNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ2xvYmFsRmlsdGVyJywgdGFibGUpLFxuICAgICAgZ2xvYmFsRmlsdGVyRm46ICdhdXRvJyxcbiAgICAgIGdldENvbHVtbkNhbkdsb2JhbEZpbHRlcjogY29sdW1uID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRnZXRDb3JlUm93TW9kZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoX3RhYmxlJGdldENvcmVSb3dNb2RlID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF0pID09IG51bGwgfHwgKF90YWJsZSRnZXRDb3JlUm93TW9kZSA9IF90YWJsZSRnZXRDb3JlUm93TW9kZS5fZ2V0QWxsQ2VsbHNCeUNvbHVtbklkKClbY29sdW1uLmlkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb3JlUm93TW9kZS5nZXRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0Q2FuR2xvYmFsRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyLCBfdGFibGUkb3B0aW9ucyRnZXRDb2w7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVHbG9iYWxGaWx0ZXIpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRnZXRDb2wgPSB0YWJsZS5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlciA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIoY29sdW1uKSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldENvbCA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyRm5zLmluY2x1ZGVzU3RyaW5nO1xuICAgIH07XG4gICAgdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZmlsdGVyLCBfdGFibGUkb3B0aW9ucyRmaWx0ZXIyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBnbG9iYWxGaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm5cbiAgICAgIH0gPSB0YWJsZS5vcHRpb25zO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZ2xvYmFsRmlsdGVyRm4pID8gZ2xvYmFsRmlsdGVyRm4gOiBnbG9iYWxGaWx0ZXJGbiA9PT0gJ2F1dG8nID8gdGFibGUuZ2V0R2xvYmFsQXV0b0ZpbHRlckZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyID0gKF90YWJsZSRvcHRpb25zJGZpbHRlcjIgPSB0YWJsZS5vcHRpb25zLmZpbHRlckZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGZpbHRlcjJbZ2xvYmFsRmlsdGVyRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZmlsdGVyIDogZmlsdGVyRm5zW2dsb2JhbEZpbHRlckZuXTtcbiAgICB9O1xuICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlciA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vbkdsb2JhbEZpbHRlckNoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UodXBkYXRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEdsb2JhbEZpbHRlciA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRHbG9iYWxGaWx0ZXIoZGVmYXVsdFN0YXRlID8gdW5kZWZpbmVkIDogdGFibGUuaW5pdGlhbFN0YXRlLmdsb2JhbEZpbHRlcik7XG4gICAgfTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgUm93RXhwYW5kaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwYW5kZWQ6IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkV4cGFuZGVkQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdleHBhbmRlZCcsIHRhYmxlKSxcbiAgICAgIHBhZ2luYXRlRXhwYW5kZWRSb3dzOiB0cnVlXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICBsZXQgcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGxldCBxdWV1ZWQgPSBmYWxzZTtcbiAgICB0YWJsZS5fYXV0b1Jlc2V0RXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3RhYmxlJG9wdGlvbnMkYXV0b1JlO1xuICAgICAgaWYgKCFyZWdpc3RlcmVkKSB7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkYXV0b1JlID0gdGFibGUub3B0aW9ucy5hdXRvUmVzZXRBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRhdXRvUmUgOiB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEV4cGFuZGVkKSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbEV4cGFuZGluZykge1xuICAgICAgICBpZiAocXVldWVkKSByZXR1cm47XG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgdGFibGUucmVzZXRFeHBhbmRlZCgpO1xuICAgICAgICAgIHF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlLnNldEV4cGFuZGVkID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25FeHBhbmRlZENoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQgPSBleHBhbmRlZCA9PiB7XG4gICAgICBpZiAoZXhwYW5kZWQgIT0gbnVsbCA/IGV4cGFuZGVkIDogIXRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkKCkpIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJsZS5zZXRFeHBhbmRlZCh7fSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEV4cGFuZGVkID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGUsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRFeHBhbmRlZChkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGUgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuZXhwYW5kZWQpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGUgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRDYW5Tb21lUm93c0V4cGFuZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cy5zb21lKHJvdyA9PiByb3cuZ2V0Q2FuRXhwYW5kKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVJvd3NFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZDtcbiAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZSB8fCBPYmplY3QudmFsdWVzKGV4cGFuZGVkKS5zb21lKEJvb2xlYW4pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG5cbiAgICAgIC8vIElmIGV4cGFuZGVkIGlzIHRydWUsIHNhdmUgc29tZSBjeWNsZXMgYW5kIHJldHVybiB0cnVlXG4gICAgICBpZiAodHlwZW9mIGV4cGFuZGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFPYmplY3Qua2V5cyhleHBhbmRlZCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IHJvdyBpcyBub3QgZXhwYW5kZWQsIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHRhYmxlLmdldFJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gIXJvdy5nZXRJc0V4cGFuZGVkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhleSBtdXN0IGFsbCBiZSBleHBhbmRlZCA6c2hydWc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHRhYmxlLmdldEV4cGFuZGVkRGVwdGggPSAoKSA9PiB7XG4gICAgICBsZXQgbWF4RGVwdGggPSAwO1xuICAgICAgY29uc3Qgcm93SWRzID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCA9PT0gdHJ1ZSA/IE9iamVjdC5rZXlzKHRhYmxlLmdldFJvd01vZGVsKCkucm93c0J5SWQpIDogT2JqZWN0LmtleXModGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCk7XG4gICAgICByb3dJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIGNvbnN0IHNwbGl0SWQgPSBpZC5zcGxpdCgnLicpO1xuICAgICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBzcGxpdElkLmxlbmd0aCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXhEZXB0aDtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RXhwYW5kZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RXhwYW5kZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcgfHwgIXRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnRvZ2dsZUV4cGFuZGVkID0gZXhwYW5kZWQgPT4ge1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQob2xkID0+IHtcbiAgICAgICAgdmFyIF9leHBhbmRlZDtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gb2xkID09PSB0cnVlID8gdHJ1ZSA6ICEhKG9sZCAhPSBudWxsICYmIG9sZFtyb3cuaWRdKTtcbiAgICAgICAgbGV0IG9sZEV4cGFuZGVkID0ge307XG4gICAgICAgIGlmIChvbGQgPT09IHRydWUpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3NCeUlkKS5mb3JFYWNoKHJvd0lkID0+IHtcbiAgICAgICAgICAgIG9sZEV4cGFuZGVkW3Jvd0lkXSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkRXhwYW5kZWQgPSBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZXhwYW5kZWQgPSAoX2V4cGFuZGVkID0gZXhwYW5kZWQpICE9IG51bGwgPyBfZXhwYW5kZWQgOiAhZXhpc3RzO1xuICAgICAgICBpZiAoIWV4aXN0cyAmJiBleHBhbmRlZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5vbGRFeHBhbmRlZCxcbiAgICAgICAgICAgIFtyb3cuaWRdOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RzICYmICFleHBhbmRlZCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIFtyb3cuaWRdOiBfLFxuICAgICAgICAgICAgLi4ucmVzdFxuICAgICAgICAgIH0gPSBvbGRFeHBhbmRlZDtcbiAgICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRJc1I7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG4gICAgICByZXR1cm4gISEoKF90YWJsZSRvcHRpb25zJGdldElzUiA9IHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRJc1Jvd0V4cGFuZGVkKHJvdykpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRJc1IgOiBleHBhbmRlZCA9PT0gdHJ1ZSB8fCAoZXhwYW5kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cGFuZGVkW3Jvdy5pZF0pKTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5FeHBhbmQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0Um93LCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF9yb3ckc3ViUm93cztcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZ2V0Um93ID0gdGFibGUub3B0aW9ucy5nZXRSb3dDYW5FeHBhbmQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kKHJvdykpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRSb3cgOiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRXhwYW5kaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgISEoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH07XG4gICAgcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgbGV0IGlzRnVsbHlFeHBhbmRlZCA9IHRydWU7XG4gICAgICBsZXQgY3VycmVudFJvdyA9IHJvdztcbiAgICAgIHdoaWxlIChpc0Z1bGx5RXhwYW5kZWQgJiYgY3VycmVudFJvdy5wYXJlbnRJZCkge1xuICAgICAgICBjdXJyZW50Um93ID0gdGFibGUuZ2V0Um93KGN1cnJlbnRSb3cucGFyZW50SWQsIHRydWUpO1xuICAgICAgICBpc0Z1bGx5RXhwYW5kZWQgPSBjdXJyZW50Um93LmdldElzRXhwYW5kZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bGx5RXhwYW5kZWQ7XG4gICAgfTtcbiAgICByb3cuZ2V0VG9nZ2xlRXhwYW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuRXhwYW5kID0gcm93LmdldENhbkV4cGFuZCgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5FeHBhbmQpIHJldHVybjtcbiAgICAgICAgcm93LnRvZ2dsZUV4cGFuZGVkKCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IGRlZmF1bHRQYWdlSW5kZXggPSAwO1xuY29uc3QgZGVmYXVsdFBhZ2VTaXplID0gMTA7XG5jb25zdCBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlID0gKCkgPT4gKHtcbiAgcGFnZUluZGV4OiBkZWZhdWx0UGFnZUluZGV4LFxuICBwYWdlU2l6ZTogZGVmYXVsdFBhZ2VTaXplXG59KTtcbmNvbnN0IFJvd1BhZ2luYXRpb24gPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgLi4uZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpLFxuICAgICAgICAuLi4oc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLnBhZ2luYXRpb24pXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25QYWdpbmF0aW9uQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdwYWdpbmF0aW9uJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICBsZXQgcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGxldCBxdWV1ZWQgPSBmYWxzZTtcbiAgICB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRvcHRpb25zJGF1dG9SZTtcbiAgICAgIGlmICghcmVnaXN0ZXJlZCkge1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGF1dG9SZSA9IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0QWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYXV0b1JlIDogdGFibGUub3B0aW9ucy5hdXRvUmVzZXRQYWdlSW5kZXgpICE9IG51bGwgPyBfcmVmIDogIXRhYmxlLm9wdGlvbnMubWFudWFsUGFnaW5hdGlvbikge1xuICAgICAgICBpZiAocXVldWVkKSByZXR1cm47XG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgdGFibGUucmVzZXRQYWdlSW5kZXgoKTtcbiAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdpbmF0aW9uID0gdXBkYXRlciA9PiB7XG4gICAgICBjb25zdCBzYWZlVXBkYXRlciA9IG9sZCA9PiB7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLm9uUGFnaW5hdGlvbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2Uoc2FmZVVwZGF0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdpbmF0aW9uID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHA7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAgPSB0YWJsZS5pbml0aWFsU3RhdGUucGFnaW5hdGlvbikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcCA6IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlSW5kZXggPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcbiAgICAgICAgbGV0IHBhZ2VJbmRleCA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VJbmRleCk7XG4gICAgICAgIGNvbnN0IG1heFBhZ2VJbmRleCA9IHR5cGVvZiB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09IC0xID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCAtIDE7XG4gICAgICAgIHBhZ2VJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VJbmRleCwgbWF4UGFnZUluZGV4KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHBhZ2VJbmRleFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldFBhZ2VJbmRleCA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiwgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldFBhZ2VJbmRleChkZWZhdWx0U3RhdGUgPyBkZWZhdWx0UGFnZUluZGV4IDogKF90YWJsZSRpbml0aWFsU3RhdGUkcDIgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCB8fCAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IF90YWJsZSRpbml0aWFsU3RhdGUucGFnaW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUucGFnZUluZGV4KSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiA6IGRlZmF1bHRQYWdlSW5kZXgpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdlU2l6ZSA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwMywgX3RhYmxlJGluaXRpYWxTdGF0ZTI7XG4gICAgICB0YWJsZS5zZXRQYWdlU2l6ZShkZWZhdWx0U3RhdGUgPyBkZWZhdWx0UGFnZVNpemUgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyA9IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCB8fCAoX3RhYmxlJGluaXRpYWxTdGF0ZTIgPSBfdGFibGUkaW5pdGlhbFN0YXRlMi5wYWdpbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZTIucGFnZVNpemUpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAzIDogZGVmYXVsdFBhZ2VTaXplKTtcbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2VTaXplID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2VTaXplID0gTWF0aC5tYXgoMSwgZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQucGFnZVNpemUpKTtcbiAgICAgICAgY29uc3QgdG9wUm93SW5kZXggPSBvbGQucGFnZVNpemUgKiBvbGQucGFnZUluZGV4O1xuICAgICAgICBjb25zdCBwYWdlSW5kZXggPSBNYXRoLmZsb29yKHRvcFJvd0luZGV4IC8gcGFnZVNpemUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlSW5kZXgsXG4gICAgICAgICAgcGFnZVNpemVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy9kZXByZWNhdGVkXG4gICAgdGFibGUuc2V0UGFnZUNvdW50ID0gdXBkYXRlciA9PiB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkcGFnZUNvO1xuICAgICAgbGV0IG5ld1BhZ2VDb3VudCA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgKF90YWJsZSRvcHRpb25zJHBhZ2VDbyA9IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcGFnZUNvIDogLTEpO1xuICAgICAgaWYgKHR5cGVvZiBuZXdQYWdlQ291bnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5ld1BhZ2VDb3VudCA9IE1hdGgubWF4KC0xLCBuZXdQYWdlQ291bnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub2xkLFxuICAgICAgICBwYWdlQ291bnQ6IG5ld1BhZ2VDb3VudFxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0YWJsZS5nZXRQYWdlT3B0aW9ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFBhZ2VDb3VudCgpXSwgcGFnZUNvdW50ID0+IHtcbiAgICAgIGxldCBwYWdlT3B0aW9ucyA9IFtdO1xuICAgICAgaWYgKHBhZ2VDb3VudCAmJiBwYWdlQ291bnQgPiAwKSB7XG4gICAgICAgIHBhZ2VPcHRpb25zID0gWy4uLm5ldyBBcnJheShwYWdlQ291bnQpXS5maWxsKG51bGwpLm1hcCgoXywgaSkgPT4gaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFnZU9wdGlvbnM7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0UGFnZU9wdGlvbnMnKSk7XG4gICAgdGFibGUuZ2V0Q2FuUHJldmlvdXNQYWdlID0gKCkgPT4gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VJbmRleCA+IDA7XG4gICAgdGFibGUuZ2V0Q2FuTmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VJbmRleFxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbjtcbiAgICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRhYmxlLmdldFBhZ2VDb3VudCgpO1xuICAgICAgaWYgKHBhZ2VDb3VudCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWdlSW5kZXggPCBwYWdlQ291bnQgLSAxO1xuICAgIH07XG4gICAgdGFibGUucHJldmlvdXNQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4gb2xkIC0gMSk7XG4gICAgfTtcbiAgICB0YWJsZS5uZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgob2xkID0+IHtcbiAgICAgICAgcmV0dXJuIG9sZCArIDE7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLmZpcnN0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgoMCk7XG4gICAgfTtcbiAgICB0YWJsZS5sYXN0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgodGFibGUuZ2V0UGFnZUNvdW50KCkgLSAxKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRQYWdpbmF0aW9uUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24gfHwgIXRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFBhZ2VDb3VudCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRwYWdlQ28yO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRwYWdlQ28yID0gdGFibGUub3B0aW9ucy5wYWdlQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRwYWdlQ28yIDogTWF0aC5jZWlsKHRhYmxlLmdldFJvd0NvdW50KCkgLyB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZVNpemUpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Um93Q291bnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkcm93Q291O1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRyb3dDb3UgPSB0YWJsZS5vcHRpb25zLnJvd0NvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcm93Q291IDogdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkucm93cy5sZW5ndGg7XG4gICAgfTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSA9ICgpID0+ICh7XG4gIHRvcDogW10sXG4gIGJvdHRvbTogW11cbn0pO1xuY29uc3QgUm93UGlubmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd1Bpbm5pbmc6IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUoKSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Sb3dQaW5uaW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdyb3dQaW5uaW5nJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy5waW4gPSAocG9zaXRpb24sIGluY2x1ZGVMZWFmUm93cywgaW5jbHVkZVBhcmVudFJvd3MpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZSb3dJZHMgPSBpbmNsdWRlTGVhZlJvd3MgPyByb3cuZ2V0TGVhZlJvd3MoKS5tYXAoX3JlZiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCBwYXJlbnRSb3dJZHMgPSBpbmNsdWRlUGFyZW50Um93cyA/IHJvdy5nZXRQYXJlbnRSb3dzKCkubWFwKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCByb3dJZHMgPSBuZXcgU2V0KFsuLi5wYXJlbnRSb3dJZHMsIHJvdy5pZCwgLi4ubGVhZlJvd0lkc10pO1xuICAgICAgdGFibGUuc2V0Um93UGlubmluZyhvbGQgPT4ge1xuICAgICAgICB2YXIgX29sZCR0b3AzLCBfb2xkJGJvdHRvbTM7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB2YXIgX29sZCR0b3AsIF9vbGQkYm90dG9tO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6ICgoX29sZCR0b3AgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcCA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSxcbiAgICAgICAgICAgIGJvdHRvbTogWy4uLigoX29sZCRib3R0b20gPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbSA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSwgLi4uQXJyYXkuZnJvbShyb3dJZHMpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIHZhciBfb2xkJHRvcDIsIF9vbGQkYm90dG9tMjtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBbLi4uKChfb2xkJHRvcDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcDIgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV0sXG4gICAgICAgICAgICBib3R0b206ICgoX29sZCRib3R0b20yID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20yIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogKChfb2xkJHRvcDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcDMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksXG4gICAgICAgICAgYm90dG9tOiAoKF9vbGQkYm90dG9tMyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tMyA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuUGluID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmFibGVSb3dQaW5uaW5nLFxuICAgICAgICBlbmFibGVQaW5uaW5nXG4gICAgICB9ID0gdGFibGUub3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2YgZW5hYmxlUm93UGlubmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZW5hYmxlUm93UGlubmluZyhyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfcmVmMyA9IGVuYWJsZVJvd1Bpbm5pbmcgIT0gbnVsbCA/IGVuYWJsZVJvd1Bpbm5pbmcgOiBlbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZjMgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgcm93SWRzID0gW3Jvdy5pZF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgY29uc3QgaXNUb3AgPSByb3dJZHMuc29tZShkID0+IHRvcCA9PSBudWxsID8gdm9pZCAwIDogdG9wLmluY2x1ZGVzKGQpKTtcbiAgICAgIGNvbnN0IGlzQm90dG9tID0gcm93SWRzLnNvbWUoZCA9PiBib3R0b20gPT0gbnVsbCA/IHZvaWQgMCA6IGJvdHRvbS5pbmNsdWRlcyhkKSk7XG4gICAgICByZXR1cm4gaXNUb3AgPyAndG9wJyA6IGlzQm90dG9tID8gJ2JvdHRvbScgOiBmYWxzZTtcbiAgICB9O1xuICAgIHJvdy5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmNCwgX3Zpc2libGVQaW5uZWRSb3dJZHMkO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSByb3cuZ2V0SXNQaW5uZWQoKTtcbiAgICAgIGlmICghcG9zaXRpb24pIHJldHVybiAtMTtcbiAgICAgIGNvbnN0IHZpc2libGVQaW5uZWRSb3dJZHMgPSAoX3JlZjQgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgPyB0YWJsZS5nZXRUb3BSb3dzKCkgOiB0YWJsZS5nZXRCb3R0b21Sb3dzKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmNC5tYXAoX3JlZjUgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmNTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKF92aXNpYmxlUGlubmVkUm93SWRzJCA9IHZpc2libGVQaW5uZWRSb3dJZHMgPT0gbnVsbCA/IHZvaWQgMCA6IHZpc2libGVQaW5uZWRSb3dJZHMuaW5kZXhPZihyb3cuaWQpKSAhPSBudWxsID8gX3Zpc2libGVQaW5uZWRSb3dJZHMkIDogLTE7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRSb3dQaW5uaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblJvd1Bpbm5pbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRSb3dQaW5uaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHIsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Um93UGlubmluZyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRyID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnJvd1Bpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHIgOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1Bpbm5lZCA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfcGlubmluZ1N0YXRlJHBvc2l0aW87XG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmc7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcGlubmluZ1N0YXRlJHRvcCwgX3Bpbm5pbmdTdGF0ZSRib3R0b207XG4gICAgICAgIHJldHVybiBCb29sZWFuKCgoX3Bpbm5pbmdTdGF0ZSR0b3AgPSBwaW5uaW5nU3RhdGUudG9wKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSR0b3AubGVuZ3RoKSB8fCAoKF9waW5uaW5nU3RhdGUkYm90dG9tID0gcGlubmluZ1N0YXRlLmJvdHRvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkYm90dG9tLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oKF9waW5uaW5nU3RhdGUkcG9zaXRpbyA9IHBpbm5pbmdTdGF0ZVtwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJHBvc2l0aW8ubGVuZ3RoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRQaW5uZWRSb3dzID0gKHZpc2libGVSb3dzLCBwaW5uZWRSb3dJZHMsIHBvc2l0aW9uKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMka2VlcFBpO1xuICAgICAgY29uc3Qgcm93cyA9ICgoX3RhYmxlJG9wdGlvbnMka2VlcFBpID0gdGFibGUub3B0aW9ucy5rZWVwUGlubmVkUm93cykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGtlZXBQaSA6IHRydWUpID9cbiAgICAgIC8vZ2V0IGFsbCByb3dzIHRoYXQgYXJlIHBpbm5lZCBldmVuIGlmIHRoZXkgd291bGQgbm90IGJlIG90aGVyd2lzZSB2aXNpYmxlXG4gICAgICAvL2FjY291bnQgZm9yIGV4cGFuZGVkIHBhcmVudCByb3dzLCBidXQgbm90IHBhZ2luYXRpb24gb3IgZmlsdGVyaW5nXG4gICAgICAocGlubmVkUm93SWRzICE9IG51bGwgPyBwaW5uZWRSb3dJZHMgOiBbXSkubWFwKHJvd0lkID0+IHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KHJvd0lkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJvdy5nZXRJc0FsbFBhcmVudHNFeHBhbmRlZCgpID8gcm93IDogbnVsbDtcbiAgICAgIH0pIDpcbiAgICAgIC8vZWxzZSBnZXQgb25seSB2aXNpYmxlIHJvd3MgdGhhdCBhcmUgcGlubmVkXG4gICAgICAocGlubmVkUm93SWRzICE9IG51bGwgPyBwaW5uZWRSb3dJZHMgOiBbXSkubWFwKHJvd0lkID0+IHZpc2libGVSb3dzLmZpbmQocm93ID0+IHJvdy5pZCA9PT0gcm93SWQpKTtcbiAgICAgIHJldHVybiByb3dzLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICBwb3NpdGlvblxuICAgICAgfSkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9wUm93cyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJvd01vZGVsKCkucm93cywgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLnRvcF0sIChhbGxSb3dzLCB0b3BQaW5uZWRSb3dJZHMpID0+IHRhYmxlLl9nZXRQaW5uZWRSb3dzKGFsbFJvd3MsIHRvcFBpbm5lZFJvd0lkcywgJ3RvcCcpLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldFRvcFJvd3MnKSk7XG4gICAgdGFibGUuZ2V0Qm90dG9tUm93cyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJvd01vZGVsKCkucm93cywgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLmJvdHRvbV0sIChhbGxSb3dzLCBib3R0b21QaW5uZWRSb3dJZHMpID0+IHRhYmxlLl9nZXRQaW5uZWRSb3dzKGFsbFJvd3MsIGJvdHRvbVBpbm5lZFJvd0lkcywgJ2JvdHRvbScpLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldEJvdHRvbVJvd3MnKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyUm93cyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJvd01vZGVsKCkucm93cywgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLnRvcCwgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLmJvdHRvbV0sIChhbGxSb3dzLCB0b3AsIGJvdHRvbSkgPT4ge1xuICAgICAgY29uc3QgdG9wQW5kQm90dG9tID0gbmV3IFNldChbLi4uKHRvcCAhPSBudWxsID8gdG9wIDogW10pLCAuLi4oYm90dG9tICE9IG51bGwgPyBib3R0b20gOiBbXSldKTtcbiAgICAgIHJldHVybiBhbGxSb3dzLmZpbHRlcihkID0+ICF0b3BBbmRCb3R0b20uaGFzKGQuaWQpKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldENlbnRlclJvd3MnKSk7XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IFJvd1NlbGVjdGlvbiA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd1NlbGVjdGlvbjoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUm93U2VsZWN0aW9uQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdyb3dTZWxlY3Rpb24nLCB0YWJsZSksXG4gICAgICBlbmFibGVSb3dTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZVN1YlJvd1NlbGVjdGlvbjogdHJ1ZVxuICAgICAgLy8gZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgLy8gaXNBZGRpdGl2ZVNlbGVjdEV2ZW50OiAoZTogdW5rbm93bikgPT4gISFlLm1ldGFLZXksXG4gICAgICAvLyBpc0luY2x1c2l2ZVNlbGVjdEV2ZW50OiAoZTogdW5rbm93bikgPT4gISFlLnNoaWZ0S2V5LFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Um93U2VsZWN0aW9uID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uUm93U2VsZWN0aW9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUm93U2VsZWN0aW9uQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Um93U2VsZWN0aW9uID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHI7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Um93U2VsZWN0aW9uKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IHRhYmxlLmluaXRpYWxTdGF0ZS5yb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHIgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQgPSB2YWx1ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQoKTtcbiAgICAgICAgY29uc3Qgcm93U2VsZWN0aW9uID0ge1xuICAgICAgICAgIC4uLm9sZFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcmVHcm91cGVkRmxhdFJvd3MgPSB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKS5mbGF0Um93cztcblxuICAgICAgICAvLyBXZSBkb24ndCB1c2UgYG11dGF0ZVJvd0lzU2VsZWN0ZWRgIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICAgIC8vIEFsbCBvZiB0aGUgcm93cyBhcmUgZmxhdCBhbHJlYWR5LCBzbyBpdCB3b3VsZG4ndCBiZSB3b3J0aCBpdFxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBwcmVHcm91cGVkRmxhdFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgaWYgKCFyb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93U2VsZWN0aW9uW3Jvdy5pZF0gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBkZWxldGUgcm93U2VsZWN0aW9uW3Jvdy5pZF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd1NlbGVjdGlvbjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCA9IHZhbHVlID0+IHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKTtcbiAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHtcbiAgICAgICAgLi4ub2xkXG4gICAgICB9O1xuICAgICAgdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChyb3dTZWxlY3Rpb24sIHJvdy5pZCwgcmVzb2x2ZWRWYWx1ZSwgdHJ1ZSwgdGFibGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcm93U2VsZWN0aW9uO1xuICAgIH0pO1xuXG4gICAgLy8gYWRkUm93U2VsZWN0aW9uUmFuZ2U6IHJvd0lkID0+IHtcbiAgICAvLyAgIGNvbnN0IHtcbiAgICAvLyAgICAgcm93cyxcbiAgICAvLyAgICAgcm93c0J5SWQsXG4gICAgLy8gICAgIG9wdGlvbnM6IHsgc2VsZWN0R3JvdXBpbmdSb3dzLCBzZWxlY3RTdWJSb3dzIH0sXG4gICAgLy8gICB9ID0gdGFibGVcblxuICAgIC8vICAgY29uc3QgZmluZFNlbGVjdGVkUm93ID0gKHJvd3M6IFJvd1tdKSA9PiB7XG4gICAgLy8gICAgIGxldCBmb3VuZFxuICAgIC8vICAgICByb3dzLmZpbmQoZCA9PiB7XG4gICAgLy8gICAgICAgaWYgKGQuZ2V0SXNTZWxlY3RlZCgpKSB7XG4gICAgLy8gICAgICAgICBmb3VuZCA9IGRcbiAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIGNvbnN0IHN1YkZvdW5kID0gZmluZFNlbGVjdGVkUm93KGQuc3ViUm93cyB8fCBbXSlcbiAgICAvLyAgICAgICBpZiAoc3ViRm91bmQpIHtcbiAgICAvLyAgICAgICAgIGZvdW5kID0gc3ViRm91bmRcbiAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIHJldHVybiBmYWxzZVxuICAgIC8vICAgICB9KVxuICAgIC8vICAgICByZXR1cm4gZm91bmRcbiAgICAvLyAgIH1cblxuICAgIC8vICAgY29uc3QgZmlyc3RSb3cgPSBmaW5kU2VsZWN0ZWRSb3cocm93cykgfHwgcm93c1swXVxuICAgIC8vICAgY29uc3QgbGFzdFJvdyA9IHJvd3NCeUlkW3Jvd0lkXVxuXG4gICAgLy8gICBsZXQgaW5jbHVkZSA9IGZhbHNlXG4gICAgLy8gICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHt9XG5cbiAgICAvLyAgIGNvbnN0IGFkZFJvdyA9IChyb3c6IFJvdykgPT4ge1xuICAgIC8vICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHRydWUsIHtcbiAgICAvLyAgICAgICByb3dzQnlJZCxcbiAgICAvLyAgICAgICBzZWxlY3RHcm91cGluZ1Jvd3M6IHNlbGVjdEdyb3VwaW5nUm93cyEsXG4gICAgLy8gICAgICAgc2VsZWN0U3ViUm93czogc2VsZWN0U3ViUm93cyEsXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHRhYmxlLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIC8vICAgICBjb25zdCBpc0ZpcnN0Um93ID0gcm93LmlkID09PSBmaXJzdFJvdy5pZFxuICAgIC8vICAgICBjb25zdCBpc0xhc3RSb3cgPSByb3cuaWQgPT09IGxhc3RSb3cuaWRcblxuICAgIC8vICAgICBpZiAoaXNGaXJzdFJvdyB8fCBpc0xhc3RSb3cpIHtcbiAgICAvLyAgICAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAvLyAgICAgICAgIGluY2x1ZGUgPSB0cnVlXG4gICAgLy8gICAgICAgfSBlbHNlIGlmIChpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgICBhZGRSb3cocm93KVxuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IGZhbHNlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG5cbiAgICAvLyAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAvLyAgICAgICBhZGRSb3cocm93KVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9KVxuXG4gICAgLy8gICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24oc2VsZWN0ZWRSb3dJZHMpXG4gICAgLy8gfSxcbiAgICB0YWJsZS5nZXRQcmVTZWxlY3RlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0U2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFNlbGVjdGVkUm93TW9kZWwnKSk7XG4gICAgdGFibGUuZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCcpKTtcbiAgICB0YWJsZS5nZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwnKSk7XG5cbiAgICAvLy9cblxuICAgIC8vIGdldEdyb3VwaW5nUm93Q2FuU2VsZWN0OiByb3dJZCA9PiB7XG4gICAgLy8gICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQpXG5cbiAgICAvLyAgIGlmICghcm93KSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcigpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbihyb3cpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID8/IGZhbHNlXG4gICAgLy8gfSxcblxuICAgIHRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgbGV0IGlzQWxsUm93c1NlbGVjdGVkID0gQm9vbGVhbihwcmVHcm91cGVkRmxhdFJvd3MubGVuZ3RoICYmIE9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKTtcbiAgICAgIGlmIChpc0FsbFJvd3NTZWxlY3RlZCkge1xuICAgICAgICBpZiAocHJlR3JvdXBlZEZsYXRSb3dzLnNvbWUocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSAmJiAhcm93U2VsZWN0aW9uW3Jvdy5pZF0pKSB7XG4gICAgICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQWxsUm93c1NlbGVjdGVkO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbkZsYXRSb3dzID0gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgbGV0IGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICEhcGFnaW5hdGlvbkZsYXRSb3dzLmxlbmd0aDtcbiAgICAgIGlmIChpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgJiYgcGFnaW5hdGlvbkZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3dTZWxlY3Rpb25bcm93LmlkXSkpIHtcbiAgICAgICAgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBbGxQYWdlUm93c1NlbGVjdGVkO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRyb3dTZTtcbiAgICAgIGNvbnN0IHRvdGFsU2VsZWN0ZWQgPSBPYmplY3Qua2V5cygoX3RhYmxlJGdldFN0YXRlJHJvd1NlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkcm93U2UgOiB7fSkubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRvdGFsU2VsZWN0ZWQgPiAwICYmIHRvdGFsU2VsZWN0ZWQgPCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3MubGVuZ3RoO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgcmV0dXJuIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpID8gZmFsc2UgOiBwYWdpbmF0aW9uRmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpLnNvbWUoZCA9PiBkLmdldElzU2VsZWN0ZWQoKSB8fCBkLmdldElzU29tZVNlbGVjdGVkKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnRvZ2dsZVNlbGVjdGVkID0gKHZhbHVlLCBvcHRzKSA9PiB7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gcm93LmdldElzU2VsZWN0ZWQoKTtcbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICB2YXIgX29wdHMkc2VsZWN0Q2hpbGRyZW47XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIWlzU2VsZWN0ZWQ7XG4gICAgICAgIGlmIChyb3cuZ2V0Q2FuU2VsZWN0KCkgJiYgaXNTZWxlY3RlZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUm93SWRzID0ge1xuICAgICAgICAgIC4uLm9sZFxuICAgICAgICB9O1xuICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHZhbHVlLCAoX29wdHMkc2VsZWN0Q2hpbGRyZW4gPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnNlbGVjdENoaWxkcmVuKSAhPSBudWxsID8gX29wdHMkc2VsZWN0Q2hpbGRyZW4gOiB0cnVlLCB0YWJsZSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFJvd0lkcztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbik7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNTb21lU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNTdWJSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbikgPT09ICdzb21lJztcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFN1YlJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKSA9PT0gJ2FsbCc7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5NdWx0aVNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuU2VsZWN0ID0gcm93LmdldENhblNlbGVjdCgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB2YXIgX3RhcmdldDtcbiAgICAgICAgaWYgKCFjYW5TZWxlY3QpIHJldHVybjtcbiAgICAgICAgcm93LnRvZ2dsZVNlbGVjdGVkKChfdGFyZ2V0ID0gZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgbXV0YXRlUm93SXNTZWxlY3RlZCA9IChzZWxlY3RlZFJvd0lkcywgaWQsIHZhbHVlLCBpbmNsdWRlQ2hpbGRyZW4sIHRhYmxlKSA9PiB7XG4gIHZhciBfcm93JHN1YlJvd3M7XG4gIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhpZCwgdHJ1ZSk7XG5cbiAgLy8gY29uc3QgaXNHcm91cGVkID0gcm93LmdldElzR3JvdXBlZCgpXG5cbiAgLy8gaWYgKCAvLyBUT0RPOiBlbmZvcmNlIGdyb3VwaW5nIHJvdyBzZWxlY3Rpb24gcnVsZXNcbiAgLy8gICAhaXNHcm91cGVkIHx8XG4gIC8vICAgKGlzR3JvdXBlZCAmJiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKVxuICAvLyApIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFyb3cuZ2V0Q2FuTXVsdGlTZWxlY3QoKSkge1xuICAgICAgT2JqZWN0LmtleXMoc2VsZWN0ZWRSb3dJZHMpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1trZXldKTtcbiAgICB9XG4gICAgaWYgKHJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgc2VsZWN0ZWRSb3dJZHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHNlbGVjdGVkUm93SWRzW2lkXTtcbiAgfVxuICAvLyB9XG5cbiAgaWYgKGluY2x1ZGVDaGlsZHJlbiAmJiAoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0Q2FuU2VsZWN0U3ViUm93cygpKSB7XG4gICAgcm93LnN1YlJvd3MuZm9yRWFjaChyb3cgPT4gbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSkpO1xuICB9XG59O1xuZnVuY3Rpb24gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCkge1xuICBjb25zdCByb3dTZWxlY3Rpb24gPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbjtcbiAgY29uc3QgbmV3U2VsZWN0ZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdTZWxlY3RlZFJvd3NCeUlkID0ge307XG5cbiAgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG4gIGNvbnN0IHJlY3Vyc2VSb3dzID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzMjtcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgIG5ld1NlbGVjdGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdTZWxlY3RlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICB9XG4gICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCkge1xuICAgICAgICByb3cgPSB7XG4gICAgICAgICAgLi4ucm93LFxuICAgICAgICAgIHN1YlJvd3M6IHJlY3Vyc2VSb3dzKHJvdy5zdWJSb3dzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH1cbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZVJvd3Mocm93TW9kZWwucm93cyksXG4gICAgZmxhdFJvd3M6IG5ld1NlbGVjdGVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld1NlbGVjdGVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUm93U2VsZWN0ZWQocm93LCBzZWxlY3Rpb24pIHtcbiAgdmFyIF9zZWxlY3Rpb24kcm93JGlkO1xuICByZXR1cm4gKF9zZWxlY3Rpb24kcm93JGlkID0gc2VsZWN0aW9uW3Jvdy5pZF0pICE9IG51bGwgPyBfc2VsZWN0aW9uJHJvdyRpZCA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTdWJSb3dTZWxlY3RlZChyb3csIHNlbGVjdGlvbiwgdGFibGUpIHtcbiAgdmFyIF9yb3ckc3ViUm93czM7XG4gIGlmICghKChfcm93JHN1YlJvd3MzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMy5sZW5ndGgpKSByZXR1cm4gZmFsc2U7XG4gIGxldCBhbGxDaGlsZHJlblNlbGVjdGVkID0gdHJ1ZTtcbiAgbGV0IHNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuICByb3cuc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgd2Uga25vdyBib3RoIG9mIHRoZXNlXG4gICAgaWYgKHNvbWVTZWxlY3RlZCAmJiAhYWxsQ2hpbGRyZW5TZWxlY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3ViUm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICBpZiAoaXNSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbikpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayByb3cgc2VsZWN0aW9uIG9mIG5lc3RlZCBzdWJyb3dzXG4gICAgaWYgKHN1YlJvdy5zdWJSb3dzICYmIHN1YlJvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9IGlzU3ViUm93U2VsZWN0ZWQoc3ViUm93LCBzZWxlY3Rpb24pO1xuICAgICAgaWYgKHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPT09ICdhbGwnKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPT09ICdzb21lJykge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFsbENoaWxkcmVuU2VsZWN0ZWQgPyAnYWxsJyA6IHNvbWVTZWxlY3RlZCA/ICdzb21lJyA6IGZhbHNlO1xufVxuXG5jb25zdCByZVNwbGl0QWxwaGFOdW1lcmljID0gLyhbMC05XSspL2dtO1xuY29uc3QgYWxwaGFudW1lcmljID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQWxwaGFudW1lcmljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSk7XG59O1xuY29uc3QgYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKSk7XG59O1xuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHQgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCkpO1xufTtcblxuLy8gVGhlIHRleHQgZmlsdGVyIGlzIG1vcmUgYmFzaWMgKGxlc3MgbnVtZXJpYyBzdXBwb3J0KVxuLy8gYnV0IGlzIG11Y2ggZmFzdGVyXG5jb25zdCB0ZXh0Q2FzZVNlbnNpdGl2ZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpKTtcbn07XG5jb25zdCBkYXRldGltZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICBjb25zdCBhID0gcm93QS5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gIGNvbnN0IGIgPSByb3dCLmdldFZhbHVlKGNvbHVtbklkKTtcblxuICAvLyBDYW4gaGFuZGxlIG51bGxpc2ggdmFsdWVzXG4gIC8vIFVzZSA+IGFuZCA8IGJlY2F1c2UgPT0gKGFuZCA9PT0pIGRvZXNuJ3Qgd29yayB3aXRoXG4gIC8vIERhdGUgb2JqZWN0cyAod291bGQgcmVxdWlyZSBjYWxsaW5nIGdldFRpbWUoKSkuXG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn07XG5jb25zdCBiYXNpYyA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpLCByb3dCLmdldFZhbHVlKGNvbHVtbklkKSk7XG59O1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBjb21wYXJlQmFzaWMoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGEpIHtcbiAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgIGlmIChpc05hTihhKSB8fCBhID09PSBJbmZpbml0eSB8fCBhID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vLyBNaXhlZCBzb3J0aW5nIGlzIHNsb3csIGJ1dCB2ZXJ5IGluY2x1c2l2ZSBvZiBtYW55IGVkZ2UgY2FzZXMuXG4vLyBJdCBoYW5kbGVzIG51bWJlcnMsIG1peGVkIGFscGhhbnVtZXJpYyBjb21iaW5hdGlvbnMsIGFuZCBldmVuXG4vLyBudWxsLCB1bmRlZmluZWQsIGFuZCBJbmZpbml0eVxuZnVuY3Rpb24gY29tcGFyZUFscGhhbnVtZXJpYyhhU3RyLCBiU3RyKSB7XG4gIC8vIFNwbGl0IG9uIG51bWJlciBncm91cHMsIGJ1dCBrZWVwIHRoZSBkZWxpbWl0ZXJcbiAgLy8gVGhlbiByZW1vdmUgZmFsc2V5IHNwbGl0IHZhbHVlc1xuICBjb25zdCBhID0gYVN0ci5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IGIgPSBiU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTtcblxuICAvLyBXaGlsZVxuICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcbiAgICBjb25zdCBhYSA9IGEuc2hpZnQoKTtcbiAgICBjb25zdCBiYiA9IGIuc2hpZnQoKTtcbiAgICBjb25zdCBhbiA9IHBhcnNlSW50KGFhLCAxMCk7XG4gICAgY29uc3QgYm4gPSBwYXJzZUludChiYiwgMTApO1xuICAgIGNvbnN0IGNvbWJvID0gW2FuLCBibl0uc29ydCgpO1xuXG4gICAgLy8gQm90aCBhcmUgc3RyaW5nXG4gICAgaWYgKGlzTmFOKGNvbWJvWzBdKSkge1xuICAgICAgaWYgKGFhID4gYmIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAoYmIgPiBhYSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBPbmUgaXMgYSBzdHJpbmcsIG9uZSBpcyBhIG51bWJlclxuICAgIGlmIChpc05hTihjb21ib1sxXSkpIHtcbiAgICAgIHJldHVybiBpc05hTihhbikgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgLy8gQm90aCBhcmUgbnVtYmVyc1xuICAgIGlmIChhbiA+IGJuKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGJuID4gYW4pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG59XG5cbi8vIEV4cG9ydHNcblxuY29uc3Qgc29ydGluZ0ZucyA9IHtcbiAgYWxwaGFudW1lcmljLFxuICBhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlLFxuICB0ZXh0LFxuICB0ZXh0Q2FzZVNlbnNpdGl2ZSxcbiAgZGF0ZXRpbWUsXG4gIGJhc2ljXG59O1xuXG4vL1xuXG5jb25zdCBSb3dTb3J0aW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydGluZzogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydGluZ0ZuOiAnYXV0bycsXG4gICAgICBzb3J0VW5kZWZpbmVkOiAxXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Tb3J0aW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdzb3J0aW5nJywgdGFibGUpLFxuICAgICAgaXNNdWx0aVNvcnRFdmVudDogZSA9PiB7XG4gICAgICAgIHJldHVybiBlLnNoaWZ0S2V5O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93cyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5zbGljZSgxMCk7XG4gICAgICBsZXQgaXNTdHJpbmcgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIGZpcnN0Um93cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJvdyA9PSBudWxsID8gdm9pZCAwIDogcm93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICByZXR1cm4gc29ydGluZ0Zucy5kYXRldGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlzU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodmFsdWUuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuYWxwaGFudW1lcmljO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nRm5zLnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc29ydGluZ0Zucy5iYXNpYztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBdXRvU29ydERpciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnYXNjJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnZGVzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U29ydGluZ0ZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHNvcnRpbiwgX3RhYmxlJG9wdGlvbnMkc29ydGluMjtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4pID8gY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gOiBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9Tb3J0aW5nRm4oKSA6IChfdGFibGUkb3B0aW9ucyRzb3J0aW4gPSAoX3RhYmxlJG9wdGlvbnMkc29ydGluMiA9IHRhYmxlLm9wdGlvbnMuc29ydGluZ0ZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJHNvcnRpbjJbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkc29ydGluIDogc29ydGluZ0Zuc1tjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbl07XG4gICAgfTtcbiAgICBjb2x1bW4udG9nZ2xlU29ydGluZyA9IChkZXNjLCBtdWx0aSkgPT4ge1xuICAgICAgLy8gaWYgKGNvbHVtbi5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgLy8gICBjb2x1bW4uY29sdW1ucy5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgICAvLyAgICAgaWYgKGMuaWQpIHtcbiAgICAgIC8vICAgICAgIHRhYmxlLnRvZ2dsZUNvbHVtblNvcnRpbmcoYy5pZCwgdW5kZWZpbmVkLCBtdWx0aSB8fCAhIWkpXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9KVxuICAgICAgLy8gICByZXR1cm5cbiAgICAgIC8vIH1cblxuICAgICAgLy8gdGhpcyBuZWVkcyB0byBiZSBvdXRzaWRlIG9mIHRhYmxlLnNldFNvcnRpbmcgdG8gYmUgaW4gc3luYyB3aXRoIHJlcmVuZGVyXG4gICAgICBjb25zdCBuZXh0U29ydGluZ09yZGVyID0gY29sdW1uLmdldE5leHRTb3J0aW5nT3JkZXIoKTtcbiAgICAgIGNvbnN0IGhhc01hbnVhbFZhbHVlID0gdHlwZW9mIGRlc2MgIT09ICd1bmRlZmluZWQnICYmIGRlc2MgIT09IG51bGw7XG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiB7XG4gICAgICAgIC8vIEZpbmQgYW55IGV4aXN0aW5nIHNvcnRpbmcgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU29ydGluZyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgbGV0IG5ld1NvcnRpbmcgPSBbXTtcblxuICAgICAgICAvLyBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIHRoaXMgc29ydCBhY3Rpb24/XG4gICAgICAgIGxldCBzb3J0QWN0aW9uO1xuICAgICAgICBsZXQgbmV4dERlc2MgPSBoYXNNYW51YWxWYWx1ZSA/IGRlc2MgOiBuZXh0U29ydGluZ09yZGVyID09PSAnZGVzYyc7XG5cbiAgICAgICAgLy8gTXVsdGktbW9kZVxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCAmJiBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgJiYgbXVsdGkpIHtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAnYWRkJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9ybWFsIG1vZGVcbiAgICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCAmJiBleGlzdGluZ0luZGV4ICE9PSBvbGQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU29ydGluZykge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0b2dnbGUgc3RhdGVzIHRoYXQgd2lsbCByZW1vdmUgdGhlIHNvcnRpbmdcbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgLy8gSWYgd2UgYXJlIFwiYWN0dWFsbHlcIiB0b2dnbGluZyAobm90IGEgbWFudWFsIHNldCB2YWx1ZSksIHNob3VsZCB3ZSByZW1vdmUgdGhlIHNvcnRpbmc/XG4gICAgICAgICAgaWYgKCFoYXNNYW51YWxWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSXMgb3VyIGludGVudGlvbiB0byByZW1vdmU/XG4gICAgICAgICAgICBpZiAoIW5leHRTb3J0aW5nT3JkZXIpIHtcbiAgICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZW1vdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TXVsO1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBbLi4ub2xkLCB7XG4gICAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICB9XTtcbiAgICAgICAgICAvLyBUYWtlIGxhdGVzdCBuIGNvbHVtbnNcbiAgICAgICAgICBuZXdTb3J0aW5nLnNwbGljZSgwLCBuZXdTb3J0aW5nLmxlbmd0aCAtICgoX3RhYmxlJG9wdGlvbnMkbWF4TXVsID0gdGFibGUub3B0aW9ucy5tYXhNdWx0aVNvcnRDb2xDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heE11bCA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAvLyBUaGlzIGZsaXBzIChvciBzZXRzKSB0aGVcbiAgICAgICAgICBuZXdTb3J0aW5nID0gb2xkLm1hcChkID0+IHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gW3tcbiAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTb3J0aW5nO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJHNvcjtcbiAgICAgIGNvbnN0IHNvcnREZXNjRmlyc3QgPSAoX3JlZiA9IChfY29sdW1uJGNvbHVtbkRlZiRzb3IgPSBjb2x1bW4uY29sdW1uRGVmLnNvcnREZXNjRmlyc3QpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRzb3IgOiB0YWJsZS5vcHRpb25zLnNvcnREZXNjRmlyc3QpICE9IG51bGwgPyBfcmVmIDogY29sdW1uLmdldEF1dG9Tb3J0RGlyKCkgPT09ICdkZXNjJztcbiAgICAgIHJldHVybiBzb3J0RGVzY0ZpcnN0ID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlciA9IG11bHRpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICBjb25zdCBmaXJzdFNvcnREaXJlY3Rpb24gPSBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyKCk7XG4gICAgICBjb25zdCBpc1NvcnRlZCA9IGNvbHVtbi5nZXRJc1NvcnRlZCgpO1xuICAgICAgaWYgKCFpc1NvcnRlZCkge1xuICAgICAgICByZXR1cm4gZmlyc3RTb3J0RGlyZWN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzU29ydGVkICE9PSBmaXJzdFNvcnREaXJlY3Rpb24gJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmdSZW1vdmFsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKFxuICAgICAgLy8gSWYgZW5hYmxlU29ydFJlbW92ZSwgZW5hYmxlIGluIGdlbmVyYWxcbiAgICAgIG11bHRpID8gKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUmVtb3ZlKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUgOiB0cnVlKSAvLyBJZiBtdWx0aSwgZG9uJ3QgYWxsb3cgaWYgZW5hYmxlTXVsdGlSZW1vdmUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1NvcnRlZCA9PT0gJ2Rlc2MnID8gJ2FzYycgOiAnZGVzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuU29ydCA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTM7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZjIsIF9jb2x1bW4kY29sdW1uRGVmJGVuYTI7XG4gICAgICByZXR1cm4gKF9yZWYyID0gKF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgOiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IF9yZWYyIDogISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1NvcnRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkc29ydGk7XG4gICAgICBjb25zdCBjb2x1bW5Tb3J0ID0gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aSA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRzb3J0aS5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgIHJldHVybiAhY29sdW1uU29ydCA/IGZhbHNlIDogY29sdW1uU29ydC5kZXNjID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U29ydEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIsIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTM7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIgPSAoX3RhYmxlJGdldFN0YXRlJHNvcnRpMyA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRzb3J0aTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIgOiAtMTtcbiAgICB9O1xuICAgIGNvbHVtbi5jbGVhclNvcnRpbmcgPSAoKSA9PiB7XG4gICAgICAvL2NsZWFyIHNvcnRpbmcgZm9yIGp1c3QgMSBjb2x1bW5cbiAgICAgIHRhYmxlLnNldFNvcnRpbmcob2xkID0+IG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggPyBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKSA6IFtdKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVTb3J0aW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhblNvcnQgPSBjb2x1bW4uZ2V0Q2FuU29ydCgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBpZiAoIWNhblNvcnQpIHJldHVybjtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nID09IG51bGwgfHwgY29sdW1uLnRvZ2dsZVNvcnRpbmcodW5kZWZpbmVkLCBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgPyB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuaXNNdWx0aVNvcnRFdmVudChlKSA6IGZhbHNlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRTb3J0aW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uU29ydGluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRTb3J0aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5zb3J0aW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRzIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldFNvcnRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFNvcnRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxTb3J0aW5nIHx8ICF0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgYnVpbHRJbkZlYXR1cmVzID0gW0hlYWRlcnMsIENvbHVtblZpc2liaWxpdHksIENvbHVtbk9yZGVyaW5nLCBDb2x1bW5QaW5uaW5nLCBDb2x1bW5GYWNldGluZywgQ29sdW1uRmlsdGVyaW5nLCBHbG9iYWxGYWNldGluZyxcbi8vZGVwZW5kcyBvbiBDb2x1bW5GYWNldGluZ1xuR2xvYmFsRmlsdGVyaW5nLFxuLy9kZXBlbmRzIG9uIENvbHVtbkZpbHRlcmluZ1xuUm93U29ydGluZywgQ29sdW1uR3JvdXBpbmcsXG4vL2RlcGVuZHMgb24gUm93U29ydGluZ1xuUm93RXhwYW5kaW5nLCBSb3dQYWdpbmF0aW9uLCBSb3dQaW5uaW5nLCBSb3dTZWxlY3Rpb24sIENvbHVtblNpemluZ107XG5cbi8vXG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJF9mZWF0dXJlcywgX29wdGlvbnMkaW5pdGlhbFN0YXRlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAob3B0aW9ucy5kZWJ1Z0FsbCB8fCBvcHRpb25zLmRlYnVnVGFibGUpKSB7XG4gICAgY29uc29sZS5pbmZvKCdDcmVhdGluZyBUYWJsZSBJbnN0YW5jZS4uLicpO1xuICB9XG4gIGNvbnN0IF9mZWF0dXJlcyA9IFsuLi5idWlsdEluRmVhdHVyZXMsIC4uLigoX29wdGlvbnMkX2ZlYXR1cmVzID0gb3B0aW9ucy5fZmVhdHVyZXMpICE9IG51bGwgPyBfb3B0aW9ucyRfZmVhdHVyZXMgOiBbXSldO1xuICBsZXQgdGFibGUgPSB7XG4gICAgX2ZlYXR1cmVzXG4gIH07XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zKHRhYmxlKSk7XG4gIH0sIHt9KTtcbiAgY29uc3QgbWVyZ2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgaWYgKHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5tZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgfTtcbiAgY29uc3QgY29yZUluaXRpYWxTdGF0ZSA9IHt9O1xuICBsZXQgaW5pdGlhbFN0YXRlID0ge1xuICAgIC4uLmNvcmVJbml0aWFsU3RhdGUsXG4gICAgLi4uKChfb3B0aW9ucyRpbml0aWFsU3RhdGUgPSBvcHRpb25zLmluaXRpYWxTdGF0ZSkgIT0gbnVsbCA/IF9vcHRpb25zJGluaXRpYWxTdGF0ZSA6IHt9KVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICB2YXIgX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0O1xuICAgIGluaXRpYWxTdGF0ZSA9IChfZmVhdHVyZSRnZXRJbml0aWFsU3QgPSBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXRJbml0aWFsU3RhdGUoaW5pdGlhbFN0YXRlKSkgIT0gbnVsbCA/IF9mZWF0dXJlJGdldEluaXRpYWxTdCA6IGluaXRpYWxTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHF1ZXVlZCA9IFtdO1xuICBsZXQgcXVldWVkVGltZW91dCA9IGZhbHNlO1xuICBjb25zdCBjb3JlSW5zdGFuY2UgPSB7XG4gICAgX2ZlYXR1cmVzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0sXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIF9xdWV1ZTogY2IgPT4ge1xuICAgICAgcXVldWVkLnB1c2goY2IpO1xuICAgICAgaWYgKCFxdWV1ZWRUaW1lb3V0KSB7XG4gICAgICAgIHF1ZXVlZFRpbWVvdXQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFNjaGVkdWxlIGEgbWljcm90YXNrIHRvIHJ1biB0aGUgcXVldWVkIGNhbGxiYWNrcyBhZnRlclxuICAgICAgICAvLyB0aGUgY3VycmVudCBjYWxsIHN0YWNrIChyZW5kZXIsIGV0YykgaGFzIGZpbmlzaGVkLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB3aGlsZSAocXVldWVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcXVldWVkLnNoaWZ0KCkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVldWVkVGltZW91dCA9IGZhbHNlO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldFN0YXRlKHRhYmxlLmluaXRpYWxTdGF0ZSk7XG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIHRhYmxlLm9wdGlvbnMpO1xuICAgICAgdGFibGUub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICB9LFxuICAgIGdldFN0YXRlOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5zdGF0ZTtcbiAgICB9LFxuICAgIHNldFN0YXRlOiB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25TdGF0ZUNoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25TdGF0ZUNoYW5nZSh1cGRhdGVyKTtcbiAgICB9LFxuICAgIF9nZXRSb3dJZDogKHJvdywgaW5kZXgsIHBhcmVudCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdztcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZ2V0Um93ID0gdGFibGUub3B0aW9ucy5nZXRSb3dJZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRSb3dJZChyb3csIGluZGV4LCBwYXJlbnQpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogYCR7cGFyZW50ID8gW3BhcmVudC5pZCwgaW5kZXhdLmpvaW4oJy4nKSA6IGluZGV4fWA7XG4gICAgfSxcbiAgICBnZXRDb3JlUm93TW9kZWw6ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldENvcmVSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRDb3JlUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwoKTtcbiAgICB9LFxuICAgIC8vIFRoZSBmaW5hbCBjYWxscyBzdGFydCBhdCB0aGUgYm90dG9tIG9mIHRoZSBtb2RlbCxcbiAgICAvLyBleHBhbmRlZCByb3dzLCB3aGljaCB0aGVuIHdvcmsgdGhlaXIgd2F5IHVwXG5cbiAgICBnZXRSb3dNb2RlbDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgIH0sXG4gICAgLy9pbiBuZXh0IHZlcnNpb24sIHdlIHNob3VsZCBqdXN0IHBhc3MgaW4gdGhlIHJvdyBtb2RlbCBhcyB0aGUgb3B0aW9uYWwgMm5kIGFyZ1xuICAgIGdldFJvdzogKGlkLCBzZWFyY2hBbGwpID0+IHtcbiAgICAgIGxldCByb3cgPSAoc2VhcmNoQWxsID8gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkgOiB0YWJsZS5nZXRSb3dNb2RlbCgpKS5yb3dzQnlJZFtpZF07XG4gICAgICBpZiAoIXJvdykge1xuICAgICAgICByb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5yb3dzQnlJZFtpZF07XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Um93IGNvdWxkIG5vdCBmaW5kIHJvdyB3aXRoIElEOiAke2lkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdztcbiAgICB9LFxuICAgIF9nZXREZWZhdWx0Q29sdW1uRGVmOiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRlZmF1bHRDb2x1bW5dLCBkZWZhdWx0Q29sdW1uID0+IHtcbiAgICAgIHZhciBfZGVmYXVsdENvbHVtbjtcbiAgICAgIGRlZmF1bHRDb2x1bW4gPSAoX2RlZmF1bHRDb2x1bW4gPSBkZWZhdWx0Q29sdW1uKSAhPSBudWxsID8gX2RlZmF1bHRDb2x1bW4gOiB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcjogcHJvcHMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ29sdW1uRGVmID0gcHJvcHMuaGVhZGVyLmNvbHVtbi5jb2x1bW5EZWY7XG4gICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmb290ZXI6IHByb3BzID0+IHByb3BzLmhlYWRlci5jb2x1bW4uaWQsXG4gICAgICAgIGNlbGw6IHByb3BzID0+IHtcbiAgICAgICAgICB2YXIgX3Byb3BzJHJlbmRlclZhbHVlJHRvLCBfcHJvcHMkcmVuZGVyVmFsdWU7XG4gICAgICAgICAgcmV0dXJuIChfcHJvcHMkcmVuZGVyVmFsdWUkdG8gPSAoX3Byb3BzJHJlbmRlclZhbHVlID0gcHJvcHMucmVuZGVyVmFsdWUoKSkgPT0gbnVsbCB8fCBfcHJvcHMkcmVuZGVyVmFsdWUudG9TdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRyZW5kZXJWYWx1ZS50b1N0cmluZygpKSAhPSBudWxsID8gX3Byb3BzJHJlbmRlclZhbHVlJHRvIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLi4udGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0RGVmYXVsdENvbHVtbkRlZigpKTtcbiAgICAgICAgfSwge30pLFxuICAgICAgICAuLi5kZWZhdWx0Q29sdW1uXG4gICAgICB9O1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnX2dldERlZmF1bHRDb2x1bW5EZWYnKSksXG4gICAgX2dldENvbHVtbkRlZnM6ICgpID0+IHRhYmxlLm9wdGlvbnMuY29sdW1ucyxcbiAgICBnZXRBbGxDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5fZ2V0Q29sdW1uRGVmcygpXSwgY29sdW1uRGVmcyA9PiB7XG4gICAgICBjb25zdCByZWN1cnNlQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2x1bW5EZWZzLCBwYXJlbnQsIGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5EZWZzLm1hcChjb2x1bW5EZWYgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KTtcbiAgICAgICAgICBjb25zdCBncm91cGluZ0NvbHVtbkRlZiA9IGNvbHVtbkRlZjtcbiAgICAgICAgICBjb2x1bW4uY29sdW1ucyA9IGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMgPyByZWN1cnNlQ29sdW1ucyhncm91cGluZ0NvbHVtbkRlZi5jb2x1bW5zLCBjb2x1bW4sIGRlcHRoICsgMSkgOiBbXTtcbiAgICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVjdXJzZUNvbHVtbnMoY29sdW1uRGVmcyk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxDb2x1bW5zJykpLFxuICAgIGdldEFsbEZsYXRDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCldLCBhbGxDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5nZXRGbGF0Q29sdW1ucygpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxGbGF0Q29sdW1ucycpKSxcbiAgICBfZ2V0QWxsRmxhdENvbHVtbnNCeUlkOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxGbGF0Q29sdW1ucygpXSwgZmxhdENvbHVtbnMgPT4ge1xuICAgICAgcmV0dXJuIGZsYXRDb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2x1bW4pID0+IHtcbiAgICAgICAgYWNjW2NvbHVtbi5pZF0gPSBjb2x1bW47XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxGbGF0Q29sdW1uc0J5SWQnKSksXG4gICAgZ2V0QWxsTGVhZkNvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCAoYWxsQ29sdW1ucywgb3JkZXJDb2x1bW5zKSA9PiB7XG4gICAgICBsZXQgbGVhZkNvbHVtbnMgPSBhbGxDb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpKTtcbiAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsTGVhZkNvbHVtbnMnKSksXG4gICAgZ2V0Q29sdW1uOiBjb2x1bW5JZCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5fZ2V0QWxsRmxhdENvbHVtbnNCeUlkKClbY29sdW1uSWRdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbHVtbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbVGFibGVdIENvbHVtbiB3aXRoIGlkICcke2NvbHVtbklkfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih0YWJsZSwgY29yZUluc3RhbmNlKTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRhYmxlLl9mZWF0dXJlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGFibGUuX2ZlYXR1cmVzW2luZGV4XTtcbiAgICBmZWF0dXJlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVUYWJsZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlVGFibGUodGFibGUpO1xuICB9XG4gIHJldHVybiB0YWJsZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29yZVJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUub3B0aW9ucy5kYXRhXSwgZGF0YSA9PiB7XG4gICAgY29uc3Qgcm93TW9kZWwgPSB7XG4gICAgICByb3dzOiBbXSxcbiAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgIHJvd3NCeUlkOiB7fVxuICAgIH07XG4gICAgY29uc3QgYWNjZXNzUm93cyA9IGZ1bmN0aW9uIChvcmlnaW5hbFJvd3MsIGRlcHRoLCBwYXJlbnRSb3cpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgYW4gZXhwZW5zaXZlIGNoZWNrIGF0IHNjYWxlLCBzbyB3ZSBzaG91bGQgbW92ZSBpdCBzb21ld2hlcmUgZWxzZSwgYnV0IHdoZXJlP1xuICAgICAgICAvLyBpZiAoIWlkKSB7XG4gICAgICAgIC8vICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Um93SWQgZXhwZWN0ZWQgYW4gSUQsIGJ1dCBnb3QgJHtpZH1gKVxuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIE1ha2UgdGhlIHJvd1xuICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3codGFibGUsIHRhYmxlLl9nZXRSb3dJZChvcmlnaW5hbFJvd3NbaV0sIGksIHBhcmVudFJvdyksIG9yaWdpbmFsUm93c1tpXSwgaSwgZGVwdGgsIHVuZGVmaW5lZCwgcGFyZW50Um93ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnRSb3cuaWQpO1xuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgZXZlcnkgcm93IGluIGEgZmxhdCBhcnJheVxuICAgICAgICByb3dNb2RlbC5mbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIC8vIEFsc28ga2VlcCB0cmFjayBvZiBldmVyeSByb3cgYnkgaXRzIElEXG4gICAgICAgIHJvd01vZGVsLnJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgIC8vIFB1c2ggdGFibGUgcm93IGludG8gcGFyZW50XG4gICAgICAgIHJvd3MucHVzaChyb3cpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgb3JpZ2luYWwgc3Vicm93c1xuICAgICAgICBpZiAodGFibGUub3B0aW9ucy5nZXRTdWJSb3dzKSB7XG4gICAgICAgICAgdmFyIF9yb3ckb3JpZ2luYWxTdWJSb3dzO1xuICAgICAgICAgIHJvdy5vcmlnaW5hbFN1YlJvd3MgPSB0YWJsZS5vcHRpb25zLmdldFN1YlJvd3Mob3JpZ2luYWxSb3dzW2ldLCBpKTtcblxuICAgICAgICAgIC8vIFRoZW4gcmVjdXJzaXZlbHkgYWNjZXNzIHRoZW1cbiAgICAgICAgICBpZiAoKF9yb3ckb3JpZ2luYWxTdWJSb3dzID0gcm93Lm9yaWdpbmFsU3ViUm93cykgIT0gbnVsbCAmJiBfcm93JG9yaWdpbmFsU3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gYWNjZXNzUm93cyhyb3cub3JpZ2luYWxTdWJSb3dzLCBkZXB0aCArIDEsIHJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuICAgIHJvd01vZGVsLnJvd3MgPSBhY2Nlc3NSb3dzKGRhdGEpO1xuICAgIHJldHVybiByb3dNb2RlbDtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0Um93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQsIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93c10sIChleHBhbmRlZCwgcm93TW9kZWwsIHBhZ2luYXRlRXhwYW5kZWRSb3dzKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCBleHBhbmRlZCAhPT0gdHJ1ZSAmJiAhT2JqZWN0LmtleXMoZXhwYW5kZWQgIT0gbnVsbCA/IGV4cGFuZGVkIDoge30pLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBpZiAoIXBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICAvLyBPbmx5IGV4cGFuZCByb3dzIGF0IHRoaXMgcG9pbnQgaWYgdGhleSBhcmUgYmVpbmcgcGFnaW5hdGVkXG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRSb3dzKHJvd01vZGVsKTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RXhwYW5kZWRSb3dNb2RlbCcpKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFJvd3Mocm93TW9kZWwpIHtcbiAgY29uc3QgZXhwYW5kZWRSb3dzID0gW107XG4gIGNvbnN0IGhhbmRsZVJvdyA9IHJvdyA9PiB7XG4gICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICBleHBhbmRlZFJvd3MucHVzaChyb3cpO1xuICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0SXNFeHBhbmRlZCgpKSB7XG4gICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgfVxuICB9O1xuICByb3dNb2RlbC5yb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgZmxhdFJvd3M6IHJvd01vZGVsLmZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkTWluTWF4VmFsdWVzKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgcmV0dXJuIFsoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXTtcbiAgfSwgZmFjZXRlZFJvd01vZGVsID0+IHtcbiAgICBpZiAoIWZhY2V0ZWRSb3dNb2RlbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MuZmxhdE1hcChmbGF0Um93ID0+IHtcbiAgICAgIHZhciBfZmxhdFJvdyRnZXRVbmlxdWVWYWw7XG4gICAgICByZXR1cm4gKF9mbGF0Um93JGdldFVuaXF1ZVZhbCA9IGZsYXRSb3cuZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKSkgIT0gbnVsbCA/IF9mbGF0Um93JGdldFVuaXF1ZVZhbCA6IFtdO1xuICAgIH0pLm1hcChOdW1iZXIpLmZpbHRlcih2YWx1ZSA9PiAhTnVtYmVyLmlzTmFOKHZhbHVlKSk7XG4gICAgaWYgKCF1bmlxdWVWYWx1ZXMubGVuZ3RoKSByZXR1cm47XG4gICAgbGV0IGZhY2V0ZWRNaW5WYWx1ZSA9IHVuaXF1ZVZhbHVlc1swXTtcbiAgICBsZXQgZmFjZXRlZE1heFZhbHVlID0gdW5pcXVlVmFsdWVzW3VuaXF1ZVZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHVuaXF1ZVZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlIDwgZmFjZXRlZE1pblZhbHVlKSBmYWNldGVkTWluVmFsdWUgPSB2YWx1ZTtlbHNlIGlmICh2YWx1ZSA+IGZhY2V0ZWRNYXhWYWx1ZSkgZmFjZXRlZE1heFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBbZmFjZXRlZE1pblZhbHVlLCBmYWNldGVkTWF4VmFsdWVdO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGYWNldGVkTWluTWF4VmFsdWVzJykpO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJSb3dzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKSB7XG4gIGlmICh0YWJsZS5vcHRpb25zLmZpbHRlckZyb21MZWFmUm93cykge1xuICAgIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpO1xufVxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tTGVhZnMocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWE7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICBjb25zdCBtYXhEZXB0aCA9IChfdGFibGUkb3B0aW9ucyRtYXhMZWEgPSB0YWJsZS5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heExlYSA6IDEwMDtcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEZpbHRlciBmcm9tIGNoaWxkcmVuIHVwIGZpcnN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9GaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xuICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgIG5ld1Jvdy5jb2x1bW5GaWx0ZXJzID0gcm93LmNvbHVtbkZpbHRlcnM7XG4gICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSAmJiAhbmV3Um93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSB8fCBuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXG4gICAgZmxhdFJvd3M6IG5ld0ZpbHRlcmVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWEyO1xuICBjb25zdCBuZXdGaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld0ZpbHRlcmVkUm93c0J5SWQgPSB7fTtcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA6IDEwMDtcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIC8vIEZpbHRlciBmcm9tIHBhcmVudHMgZG93bndhcmQgZmlyc3RcblxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gYW55IHN1YlJvd3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHJvdyA9IHJvd3NUb0ZpbHRlcltpXTtcbiAgICAgIGNvbnN0IHBhc3MgPSBmaWx0ZXJSb3cocm93KTtcbiAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3MyO1xuICAgICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgfVxuICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXIsIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChwcmVSb3dNb2RlbCwgY29sdW1uRmlsdGVycywgZ2xvYmFsRmlsdGVyKSA9PiB7XG4gICAgaWYgKCFwcmVSb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCAmJiBjb2x1bW5GaWx0ZXJzLmxlbmd0aCkgJiYgIWdsb2JhbEZpbHRlcikge1xuICAgICAgcmV0dXJuIHByZVJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJhYmxlSWRzID0gWy4uLmNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCkuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uSWQpLCBnbG9iYWxGaWx0ZXIgPyAnX19nbG9iYWxfXycgOiB1bmRlZmluZWRdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbHRlclJvd3MocHJlUm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RmFjZXRlZFJvd01vZGVsJykpO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkVW5pcXVlVmFsdWVzKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgcmV0dXJuIFsoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXTtcbiAgfSwgZmFjZXRlZFJvd01vZGVsID0+IHtcbiAgICBpZiAoIWZhY2V0ZWRSb3dNb2RlbCkgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICBsZXQgZmFjZXRlZFVuaXF1ZVZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWVzID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzW2ldLmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tqXTtcbiAgICAgICAgaWYgKGZhY2V0ZWRVbmlxdWVWYWx1ZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBfZmFjZXRlZFVuaXF1ZVZhbHVlcyQ7XG4gICAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcy5zZXQodmFsdWUsICgoX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkID0gZmFjZXRlZFVuaXF1ZVZhbHVlcy5nZXQodmFsdWUpKSAhPSBudWxsID8gX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkIDogMCkgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLnNldCh2YWx1ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhY2V0ZWRVbmlxdWVWYWx1ZXM7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgYGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXNfJHtjb2x1bW5JZH1gKSk7XG59XG5cbmZ1bmN0aW9uIGdldEZpbHRlcmVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXJdLCAocm93TW9kZWwsIGNvbHVtbkZpbHRlcnMsIGdsb2JhbEZpbHRlcikgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIShjb2x1bW5GaWx0ZXJzICE9IG51bGwgJiYgY29sdW1uRmlsdGVycy5sZW5ndGgpICYmICFnbG9iYWxGaWx0ZXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVycyA9IHt9O1xuICAgICAgICByb3dNb2RlbC5mbGF0Um93c1tpXS5jb2x1bW5GaWx0ZXJzTWV0YSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZENvbHVtbkZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCByZXNvbHZlZEdsb2JhbEZpbHRlcnMgPSBbXTtcbiAgICAoY29sdW1uRmlsdGVycyAhPSBudWxsID8gY29sdW1uRmlsdGVycyA6IFtdKS5mb3JFYWNoKGQgPT4ge1xuICAgICAgdmFyIF9maWx0ZXJGbiRyZXNvbHZlRmlsdDtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihkLmlkKTtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICBpZiAoIWZpbHRlckZuKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBhIHZhbGlkICdjb2x1bW4uZmlsdGVyRm4nIGZvciBjb2x1bW4gd2l0aCB0aGUgSUQ6ICR7Y29sdW1uLmlkfS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbHVtbkZpbHRlcnMucHVzaCh7XG4gICAgICAgIGlkOiBkLmlkLFxuICAgICAgICBmaWx0ZXJGbixcbiAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA9IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGQudmFsdWUpKSAhPSBudWxsID8gX2ZpbHRlckZuJHJlc29sdmVGaWx0IDogZC52YWx1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IChjb2x1bW5GaWx0ZXJzICE9IG51bGwgPyBjb2x1bW5GaWx0ZXJzIDogW10pLm1hcChkID0+IGQuaWQpO1xuICAgIGNvbnN0IGdsb2JhbEZpbHRlckZuID0gdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4oKTtcbiAgICBjb25zdCBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIoKSk7XG4gICAgaWYgKGdsb2JhbEZpbHRlciAmJiBnbG9iYWxGaWx0ZXJGbiAmJiBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgZmlsdGVyYWJsZUlkcy5wdXNoKCdfX2dsb2JhbF9fJyk7XG4gICAgICBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgdmFyIF9nbG9iYWxGaWx0ZXJGbiRyZXNvbDtcbiAgICAgICAgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLnB1c2goe1xuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgZmlsdGVyRm46IGdsb2JhbEZpbHRlckZuLFxuICAgICAgICAgIHJlc29sdmVkVmFsdWU6IChfZ2xvYmFsRmlsdGVyRm4kcmVzb2wgPSBnbG9iYWxGaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbEZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZShnbG9iYWxGaWx0ZXIpKSAhPSBudWxsID8gX2dsb2JhbEZpbHRlckZuJHJlc29sIDogZ2xvYmFsRmlsdGVyXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjdXJyZW50Q29sdW1uRmlsdGVyO1xuICAgIGxldCBjdXJyZW50R2xvYmFsRmlsdGVyO1xuXG4gICAgLy8gRmxhZyB0aGUgcHJlZmlsdGVyZWQgcm93IG1vZGVsIHdpdGggZWFjaCBmaWx0ZXIgc3RhdGVcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCByb3cgPSByb3dNb2RlbC5mbGF0Um93c1tqXTtcbiAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzID0ge307XG4gICAgICBpZiAocmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkQ29sdW1uRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRDb2x1bW5GaWx0ZXIgPSByZXNvbHZlZENvbHVtbkZpbHRlcnNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50Q29sdW1uRmlsdGVyLmlkO1xuXG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgY29sdW1uIGZpbHRlciBzdGF0ZVxuICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzW2lkXSA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuZmlsdGVyRm4ocm93LCBpZCwgY3VycmVudENvbHVtbkZpbHRlci5yZXNvbHZlZFZhbHVlLCBmaWx0ZXJNZXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkR2xvYmFsRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRHbG9iYWxGaWx0ZXIgPSByZXNvbHZlZEdsb2JhbEZpbHRlcnNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50R2xvYmFsRmlsdGVyLmlkO1xuICAgICAgICAgIC8vIFRhZyB0aGUgcm93IHdpdGggdGhlIGZpcnN0IHRydXRoeSBnbG9iYWwgZmlsdGVyIHN0YXRlXG4gICAgICAgICAgaWYgKGN1cnJlbnRHbG9iYWxGaWx0ZXIuZmlsdGVyRm4ocm93LCBpZCwgY3VycmVudEdsb2JhbEZpbHRlci5yZXNvbHZlZFZhbHVlLCBmaWx0ZXJNZXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBGaWx0ZXIgZmluYWwgcm93cyB1c2luZyBhbGwgb2YgdGhlIGFjdGl2ZSBmaWx0ZXJzXG4gICAgcmV0dXJuIGZpbHRlclJvd3Mocm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RmlsdGVyZWRSb3dNb2RlbCcsICgpID0+IHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKSkpO1xufVxuXG5mdW5jdGlvbiBnZXRHcm91cGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKV0sIChncm91cGluZywgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICFncm91cGluZy5sZW5ndGgpIHtcbiAgICAgIHJvd01vZGVsLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICByb3cuZGVwdGggPSAwO1xuICAgICAgICByb3cucGFyZW50SWQgPSB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgdGhlIGdyb3VwaW5nIGxpc3QgZG93biB0byBjb2x1bW5zIHRoYXQgZXhpc3RcbiAgICBjb25zdCBleGlzdGluZ0dyb3VwaW5nID0gZ3JvdXBpbmcuZmlsdGVyKGNvbHVtbklkID0+IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpO1xuICAgIGNvbnN0IGdyb3VwZWRGbGF0Um93cyA9IFtdO1xuICAgIGNvbnN0IGdyb3VwZWRSb3dzQnlJZCA9IHt9O1xuICAgIC8vIGNvbnN0IG9ubHlHcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XG4gICAgLy8gY29uc3Qgb25seUdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG4gICAgLy8gY29uc3Qgbm9uR3JvdXBlZEZsYXRSb3dzOiBSb3dbXSA9IFtdO1xuICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG5cbiAgICAvLyBSZWN1cnNpdmVseSBncm91cCB0aGUgZGF0YVxuICAgIGNvbnN0IGdyb3VwVXBSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChyb3dzLCBkZXB0aCwgcGFyZW50SWQpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEdyb3VwaW5nIGRlcHRoIGhhcyBiZWVuIGJlZW4gbWV0XG4gICAgICAvLyBTdG9wIGdyb3VwaW5nIGFuZCBzaW1wbHkgcmV3cml0ZSB0aGQgZGVwdGggYW5kIHJvdyByZWxhdGlvbnNoaXBzXG4gICAgICBpZiAoZGVwdGggPj0gZXhpc3RpbmdHcm91cGluZy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICAgICAgcm93LmRlcHRoID0gZGVwdGg7XG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBncm91cGVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBpZiAocm93LnN1YlJvd3MpIHtcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvdy5zdWJSb3dzLCBkZXB0aCArIDEsIHJvdy5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uSWQgPSBleGlzdGluZ0dyb3VwaW5nW2RlcHRoXTtcblxuICAgICAgLy8gR3JvdXAgdGhlIHJvd3MgdG9nZXRoZXIgZm9yIHRoaXMgbGV2ZWxcbiAgICAgIGNvbnN0IHJvd0dyb3Vwc01hcCA9IGdyb3VwQnkocm93cywgY29sdW1uSWQpO1xuXG4gICAgICAvLyBQZXJmb3JtIGFnZ3JlZ2F0aW9ucyBmb3IgZWFjaCBncm91cFxuICAgICAgY29uc3QgYWdncmVnYXRlZEdyb3VwZWRSb3dzID0gQXJyYXkuZnJvbShyb3dHcm91cHNNYXAuZW50cmllcygpKS5tYXAoKF9yZWYsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBbZ3JvdXBpbmdWYWx1ZSwgZ3JvdXBlZFJvd3NdID0gX3JlZjtcbiAgICAgICAgbGV0IGlkID0gYCR7Y29sdW1uSWR9OiR7Z3JvdXBpbmdWYWx1ZX1gO1xuICAgICAgICBpZCA9IHBhcmVudElkID8gYCR7cGFyZW50SWR9PiR7aWR9YCA6IGlkO1xuXG4gICAgICAgIC8vIEZpcnN0LCBSZWN1cnNlIHRvIGdyb3VwIHN1YiByb3dzIGJlZm9yZSBhZ2dyZWdhdGlvblxuICAgICAgICBjb25zdCBzdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KGdyb3VwZWRSb3dzLCBkZXB0aCArIDEsIGlkKTtcbiAgICAgICAgc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICAgICAgc3ViUm93LnBhcmVudElkID0gaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlIGxlYWYgcm93cyBvZiB0aGUgcm93cyBpbiB0aGlzIGdyb3VwXG4gICAgICAgIGNvbnN0IGxlYWZSb3dzID0gZGVwdGggPyBmbGF0dGVuQnkoZ3JvdXBlZFJvd3MsIHJvdyA9PiByb3cuc3ViUm93cykgOiBncm91cGVkUm93cztcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCBpZCwgbGVhZlJvd3NbMF0ub3JpZ2luYWwsIGluZGV4LCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRJZCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocm93LCB7XG4gICAgICAgICAgZ3JvdXBpbmdDb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgICAgZ3JvdXBpbmdWYWx1ZSxcbiAgICAgICAgICBzdWJSb3dzLFxuICAgICAgICAgIGxlYWZSb3dzLFxuICAgICAgICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICAgICAgICAvLyBEb24ndCBhZ2dyZWdhdGUgY29sdW1ucyB0aGF0IGFyZSBpbiB0aGUgZ3JvdXBpbmdcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0dyb3VwaW5nLmluY2x1ZGVzKGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGdyb3VwZWRSb3dzWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ncm91cGVkUm93cyQwJGdldFZhbDtcbiAgICAgICAgICAgICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IChfZ3JvdXBlZFJvd3MkMCRnZXRWYWwgPSBncm91cGVkUm93c1swXS5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgPyBfZ3JvdXBlZFJvd3MkMCRnZXRWYWwgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFnZ3JlZ2F0ZSB0aGUgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgICAgICAgY29uc3QgYWdncmVnYXRlRm4gPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuKCk7XG4gICAgICAgICAgICBpZiAoYWdncmVnYXRlRm4pIHtcbiAgICAgICAgICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGFnZ3JlZ2F0ZUZuKGNvbHVtbklkLCBsZWFmUm93cywgZ3JvdXBlZFJvd3MpO1xuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIGlmIChzdWJSb3cuZ2V0SXNHcm91cGVkPy4oKSkge1xuICAgICAgICAgIC8vICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgLy8gICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWdncmVnYXRlZEdyb3VwZWRSb3dzO1xuICAgIH07XG4gICAgY29uc3QgZ3JvdXBlZFJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkocm93TW9kZWwucm93cywgMCk7XG4gICAgZ3JvdXBlZFJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAvLyAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgLy8gICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgLy8gICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcm93czogZ3JvdXBlZFJvd3MsXG4gICAgICBmbGF0Um93czogZ3JvdXBlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZFxuICAgIH07XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEdyb3VwZWRSb3dNb2RlbCcsICgpID0+IHtcbiAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkKCk7XG4gICAgICB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCk7XG4gICAgfSk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnkocm93cywgY29sdW1uSWQpIHtcbiAgY29uc3QgZ3JvdXBNYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiByb3dzLnJlZHVjZSgobWFwLCByb3cpID0+IHtcbiAgICBjb25zdCByZXNLZXkgPSBgJHtyb3cuZ2V0R3JvdXBpbmdWYWx1ZShjb2x1bW5JZCl9YDtcbiAgICBjb25zdCBwcmV2aW91cyA9IG1hcC5nZXQocmVzS2V5KTtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICBtYXAuc2V0KHJlc0tleSwgW3Jvd10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91cy5wdXNoKHJvdyk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH0sIGdyb3VwTWFwKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFnaW5hdGlvblJvd01vZGVsKG9wdHMpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbiwgdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCksIHRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MgPyB1bmRlZmluZWQgOiB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkXSwgKHBhZ2luYXRpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlU2l6ZSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSBwYWdpbmF0aW9uO1xuICAgIGxldCB7XG4gICAgICByb3dzLFxuICAgICAgZmxhdFJvd3MsXG4gICAgICByb3dzQnlJZFxuICAgIH0gPSByb3dNb2RlbDtcbiAgICBjb25zdCBwYWdlU3RhcnQgPSBwYWdlU2l6ZSAqIHBhZ2VJbmRleDtcbiAgICBjb25zdCBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgcGFnZVNpemU7XG4gICAgcm93cyA9IHJvd3Muc2xpY2UocGFnZVN0YXJ0LCBwYWdlRW5kKTtcbiAgICBsZXQgcGFnaW5hdGVkUm93TW9kZWw7XG4gICAgaWYgKCF0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbCA9IGV4cGFuZFJvd3Moe1xuICAgICAgICByb3dzLFxuICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbCA9IHtcbiAgICAgICAgcm93cyxcbiAgICAgICAgZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkXG4gICAgICB9O1xuICAgIH1cbiAgICBwYWdpbmF0ZWRSb3dNb2RlbC5mbGF0Um93cyA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZVJvdyA9IHJvdyA9PiB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbC5mbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICBpZiAocm93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgIHJvdy5zdWJSb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhZ2luYXRlZFJvd01vZGVsLnJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgIHJldHVybiBwYWdpbmF0ZWRSb3dNb2RlbDtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0UGFnaW5hdGlvblJvd01vZGVsJykpO1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuc29ydGluZywgdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwoKV0sIChzb3J0aW5nLCByb3dNb2RlbCkgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIShzb3J0aW5nICE9IG51bGwgJiYgc29ydGluZy5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHNvcnRpbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZztcbiAgICBjb25zdCBzb3J0ZWRGbGF0Um93cyA9IFtdO1xuXG4gICAgLy8gRmlsdGVyIG91dCBzb3J0aW5ncyB0aGF0IGNvcnJlc3BvbmQgdG8gbm9uIGV4aXN0aW5nIGNvbHVtbnNcbiAgICBjb25zdCBhdmFpbGFibGVTb3J0aW5nID0gc29ydGluZ1N0YXRlLmZpbHRlcihzb3J0ID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0Q29sdW1uO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnQuaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvbHVtbi5nZXRDYW5Tb3J0KCk7XG4gICAgfSk7XG4gICAgY29uc3QgY29sdW1uSW5mb0J5SWQgPSB7fTtcbiAgICBhdmFpbGFibGVTb3J0aW5nLmZvckVhY2goc29ydEVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihzb3J0RW50cnkuaWQpO1xuICAgICAgaWYgKCFjb2x1bW4pIHJldHVybjtcbiAgICAgIGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF0gPSB7XG4gICAgICAgIHNvcnRVbmRlZmluZWQ6IGNvbHVtbi5jb2x1bW5EZWYuc29ydFVuZGVmaW5lZCxcbiAgICAgICAgaW52ZXJ0U29ydGluZzogY29sdW1uLmNvbHVtbkRlZi5pbnZlcnRTb3J0aW5nLFxuICAgICAgICBzb3J0aW5nRm46IGNvbHVtbi5nZXRTb3J0aW5nRm4oKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBzb3J0RGF0YSA9IHJvd3MgPT4ge1xuICAgICAgLy8gVGhpcyB3aWxsIGFsc28gcGVyZm9ybSBhIHN0YWJsZSBzb3J0aW5nIHVzaW5nIHRoZSByb3cgaW5kZXhcbiAgICAgIC8vIGlmIG5lZWRlZC5cbiAgICAgIGNvbnN0IHNvcnRlZERhdGEgPSByb3dzLm1hcChyb3cgPT4gKHtcbiAgICAgICAgLi4ucm93XG4gICAgICB9KSk7XG4gICAgICBzb3J0ZWREYXRhLnNvcnQoKHJvd0EsIHJvd0IpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdmFpbGFibGVTb3J0aW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIF9zb3J0RW50cnkkZGVzYztcbiAgICAgICAgICBjb25zdCBzb3J0RW50cnkgPSBhdmFpbGFibGVTb3J0aW5nW2ldO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbkluZm8gPSBjb2x1bW5JbmZvQnlJZFtzb3J0RW50cnkuaWRdO1xuICAgICAgICAgIGNvbnN0IHNvcnRVbmRlZmluZWQgPSBjb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgaXNEZXNjID0gKF9zb3J0RW50cnkkZGVzYyA9IHNvcnRFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogc29ydEVudHJ5LmRlc2MpICE9IG51bGwgPyBfc29ydEVudHJ5JGRlc2MgOiBmYWxzZTtcbiAgICAgICAgICBsZXQgc29ydEludCA9IDA7XG5cbiAgICAgICAgICAvLyBBbGwgc29ydGluZyBpbnRzIHNob3VsZCBhbHdheXMgcmV0dXJuIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgICAgIGlmIChzb3J0VW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBhVmFsdWUgPSByb3dBLmdldFZhbHVlKHNvcnRFbnRyeS5pZCk7XG4gICAgICAgICAgICBjb25zdCBiVmFsdWUgPSByb3dCLmdldFZhbHVlKHNvcnRFbnRyeS5pZCk7XG4gICAgICAgICAgICBjb25zdCBhVW5kZWZpbmVkID0gYVZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBiVW5kZWZpbmVkID0gYlZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoYVVuZGVmaW5lZCB8fCBiVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChzb3J0VW5kZWZpbmVkID09PSAnZmlyc3QnKSByZXR1cm4gYVVuZGVmaW5lZCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgaWYgKHNvcnRVbmRlZmluZWQgPT09ICdsYXN0JykgcmV0dXJuIGFVbmRlZmluZWQgPyAxIDogLTE7XG4gICAgICAgICAgICAgIHNvcnRJbnQgPSBhVW5kZWZpbmVkICYmIGJVbmRlZmluZWQgPyAwIDogYVVuZGVmaW5lZCA/IHNvcnRVbmRlZmluZWQgOiAtc29ydFVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvcnRJbnQgPT09IDApIHtcbiAgICAgICAgICAgIHNvcnRJbnQgPSBjb2x1bW5JbmZvLnNvcnRpbmdGbihyb3dBLCByb3dCLCBzb3J0RW50cnkuaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHNvcnRpbmcgaXMgbm9uLXplcm8sIHRha2UgY2FyZSBvZiBkZXNjIGFuZCBpbnZlcnNpb25cbiAgICAgICAgICBpZiAoc29ydEludCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbkluZm8uaW52ZXJ0U29ydGluZykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dBLmluZGV4IC0gcm93Qi5pbmRleDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgc3ViLXJvd3MsIHNvcnQgdGhlbVxuICAgICAgc29ydGVkRGF0YS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICAgIHNvcnRlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93LnN1YlJvd3MgPSBzb3J0RGF0YShyb3cuc3ViUm93cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRlZERhdGE7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcm93czogc29ydERhdGEocm93TW9kZWwucm93cyksXG4gICAgICBmbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcbiAgICB9O1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRTb3J0ZWRSb3dNb2RlbCcsICgpID0+IHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKSkpO1xufVxuXG5leHBvcnQgeyBDb2x1bW5GYWNldGluZywgQ29sdW1uRmlsdGVyaW5nLCBDb2x1bW5Hcm91cGluZywgQ29sdW1uT3JkZXJpbmcsIENvbHVtblBpbm5pbmcsIENvbHVtblNpemluZywgQ29sdW1uVmlzaWJpbGl0eSwgR2xvYmFsRmFjZXRpbmcsIEdsb2JhbEZpbHRlcmluZywgSGVhZGVycywgUm93RXhwYW5kaW5nLCBSb3dQYWdpbmF0aW9uLCBSb3dQaW5uaW5nLCBSb3dTZWxlY3Rpb24sIFJvd1NvcnRpbmcsIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnMsIGFnZ3JlZ2F0aW9uRm5zLCBidWlsZEhlYWRlckdyb3VwcywgY3JlYXRlQ2VsbCwgY3JlYXRlQ29sdW1uLCBjcmVhdGVDb2x1bW5IZWxwZXIsIGNyZWF0ZVJvdywgY3JlYXRlVGFibGUsIGRlZmF1bHRDb2x1bW5TaXppbmcsIGV4cGFuZFJvd3MsIGZpbHRlckZucywgZmxhdHRlbkJ5LCBmdW5jdGlvbmFsVXBkYXRlLCBnZXRDb3JlUm93TW9kZWwsIGdldEV4cGFuZGVkUm93TW9kZWwsIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMsIGdldEZhY2V0ZWRSb3dNb2RlbCwgZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcywgZ2V0RmlsdGVyZWRSb3dNb2RlbCwgZ2V0R3JvdXBlZFJvd01vZGVsLCBnZXRNZW1vT3B0aW9ucywgZ2V0UGFnaW5hdGlvblJvd01vZGVsLCBnZXRTb3J0ZWRSb3dNb2RlbCwgaXNGdW5jdGlvbiwgaXNOdW1iZXJBcnJheSwgaXNSb3dTZWxlY3RlZCwgaXNTdWJSb3dTZWxlY3RlZCwgbWFrZVN0YXRlVXBkYXRlciwgbWVtbywgbm9vcCwgb3JkZXJDb2x1bW5zLCBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQsIHJlU3BsaXRBbHBoYU51bWVyaWMsIHNlbGVjdFJvd3NGbiwgc2hvdWxkQXV0b1JlbW92ZUZpbHRlciwgc29ydGluZ0ZucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbHVtbkhlbHBlciIsImFjY2Vzc29yIiwiY29sdW1uIiwiYWNjZXNzb3JGbiIsImFjY2Vzc29yS2V5IiwiZGlzcGxheSIsImdyb3VwIiwiZnVuY3Rpb25hbFVwZGF0ZSIsInVwZGF0ZXIiLCJpbnB1dCIsIm5vb3AiLCJtYWtlU3RhdGVVcGRhdGVyIiwia2V5IiwiaW5zdGFuY2UiLCJzZXRTdGF0ZSIsIm9sZCIsImlzRnVuY3Rpb24iLCJkIiwiRnVuY3Rpb24iLCJpc051bWJlckFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJ2YWwiLCJmbGF0dGVuQnkiLCJhcnIiLCJnZXRDaGlsZHJlbiIsImZsYXQiLCJyZWN1cnNlIiwic3ViQXJyIiwiZm9yRWFjaCIsIml0ZW0iLCJwdXNoIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJtZW1vIiwiZ2V0RGVwcyIsImZuIiwib3B0cyIsImRlcHMiLCJyZXN1bHQiLCJkZXBBcmdzIiwiZGVwVGltZSIsImRlYnVnIiwiRGF0ZSIsIm5vdyIsIm5ld0RlcHMiLCJkZXBzQ2hhbmdlZCIsInNvbWUiLCJkZXAiLCJpbmRleCIsInJlc3VsdFRpbWUiLCJvbkNoYW5nZSIsImRlcEVuZFRpbWUiLCJNYXRoIiwicm91bmQiLCJyZXN1bHRFbmRUaW1lIiwicmVzdWx0RnBzUGVyY2VudGFnZSIsInBhZCIsInN0ciIsIm51bSIsIlN0cmluZyIsImNvbnNvbGUiLCJpbmZvIiwibWF4IiwibWluIiwiZ2V0TWVtb09wdGlvbnMiLCJ0YWJsZU9wdGlvbnMiLCJkZWJ1Z0xldmVsIiwiX3RhYmxlT3B0aW9ucyRkZWJ1Z0FsIiwiZGVidWdBbGwiLCJwcm9jZXNzIiwiY3JlYXRlQ2VsbCIsInRhYmxlIiwicm93IiwiY29sdW1uSWQiLCJnZXRSZW5kZXJWYWx1ZSIsIl9jZWxsJGdldFZhbHVlIiwiY2VsbCIsImdldFZhbHVlIiwib3B0aW9ucyIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJpZCIsInJlbmRlclZhbHVlIiwiZ2V0Q29udGV4dCIsIl9mZWF0dXJlcyIsImZlYXR1cmUiLCJjcmVhdGVDb2x1bW4iLCJjb2x1bW5EZWYiLCJkZXB0aCIsInBhcmVudCIsIl9yZWYiLCJfcmVzb2x2ZWRDb2x1bW5EZWYkaWQiLCJkZWZhdWx0Q29sdW1uIiwiX2dldERlZmF1bHRDb2x1bW5EZWYiLCJyZXNvbHZlZENvbHVtbkRlZiIsInByb3RvdHlwZSIsInJlcGxhY2VBbGwiLCJyZXBsYWNlIiwidW5kZWZpbmVkIiwiaGVhZGVyIiwiaW5jbHVkZXMiLCJvcmlnaW5hbFJvdyIsInNwbGl0IiwiX3Jlc3VsdCIsIndhcm4iLCJFcnJvciIsImNvbHVtbnMiLCJnZXRGbGF0Q29sdW1ucyIsIl9jb2x1bW4kY29sdW1ucyIsImZsYXRNYXAiLCJnZXRMZWFmQ29sdW1ucyIsIl9nZXRPcmRlckNvbHVtbnNGbiIsIm9yZGVyQ29sdW1ucyIsIl9jb2x1bW4kY29sdW1uczIiLCJsZWFmQ29sdW1ucyIsImNyZWF0ZUhlYWRlciIsIl9vcHRpb25zJGlkIiwiaXNQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVySWQiLCJzdWJIZWFkZXJzIiwiY29sU3BhbiIsInJvd1NwYW4iLCJoZWFkZXJHcm91cCIsImdldExlYWZIZWFkZXJzIiwibGVhZkhlYWRlcnMiLCJyZWN1cnNlSGVhZGVyIiwiaCIsIm1hcCIsIkhlYWRlcnMiLCJjcmVhdGVUYWJsZSIsImdldEhlYWRlckdyb3VwcyIsImdldEFsbENvbHVtbnMiLCJnZXRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRTdGF0ZSIsImNvbHVtblBpbm5pbmciLCJsZWZ0IiwicmlnaHQiLCJhbGxDb2x1bW5zIiwiX2xlZnQkbWFwJGZpbHRlciIsIl9yaWdodCRtYXAkZmlsdGVyIiwibGVmdENvbHVtbnMiLCJmaW5kIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJpZ2h0Q29sdW1ucyIsImNlbnRlckNvbHVtbnMiLCJoZWFkZXJHcm91cHMiLCJidWlsZEhlYWRlckdyb3VwcyIsImdldENlbnRlckhlYWRlckdyb3VwcyIsImdldExlZnRIZWFkZXJHcm91cHMiLCJfbGVmdCRtYXAkZmlsdGVyMiIsIm9yZGVyZWRMZWFmQ29sdW1ucyIsImdldFJpZ2h0SGVhZGVyR3JvdXBzIiwiX3JpZ2h0JG1hcCRmaWx0ZXIyIiwiZ2V0Rm9vdGVyR3JvdXBzIiwicmV2ZXJzZSIsImdldExlZnRGb290ZXJHcm91cHMiLCJnZXRDZW50ZXJGb290ZXJHcm91cHMiLCJnZXRSaWdodEZvb3Rlckdyb3VwcyIsImdldEZsYXRIZWFkZXJzIiwiaGVhZGVycyIsImdldExlZnRGbGF0SGVhZGVycyIsImdldENlbnRlckZsYXRIZWFkZXJzIiwiZ2V0UmlnaHRGbGF0SGVhZGVycyIsImdldENlbnRlckxlYWZIZWFkZXJzIiwiZmxhdEhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMiLCJnZXRMZWZ0TGVhZkhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMyIiwiZ2V0UmlnaHRMZWFmSGVhZGVycyIsIl9oZWFkZXIkc3ViSGVhZGVyczMiLCJjZW50ZXIiLCJfbGVmdCQwJGhlYWRlcnMiLCJfbGVmdCQiLCJfY2VudGVyJDAkaGVhZGVycyIsIl9jZW50ZXIkIiwiX3JpZ2h0JDAkaGVhZGVycyIsIl9yaWdodCQiLCJjb2x1bW5zVG9Hcm91cCIsImhlYWRlckZhbWlseSIsIl9oZWFkZXJHcm91cHMkMCRoZWFkZSIsIl9oZWFkZXJHcm91cHMkIiwibWF4RGVwdGgiLCJmaW5kTWF4RGVwdGgiLCJnZXRJc1Zpc2libGUiLCJjcmVhdGVIZWFkZXJHcm91cCIsImhlYWRlcnNUb0dyb3VwIiwiam9pbiIsInBlbmRpbmdQYXJlbnRIZWFkZXJzIiwiaGVhZGVyVG9Hcm91cCIsImxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIiLCJpc0xlYWZIZWFkZXIiLCJib3R0b21IZWFkZXJzIiwicmVjdXJzZUhlYWRlcnNGb3JTcGFucyIsImZpbHRlcmVkSGVhZGVycyIsImNoaWxkUm93U3BhbnMiLCJjaGlsZENvbFNwYW4iLCJjaGlsZFJvd1NwYW4iLCJtaW5DaGlsZFJvd1NwYW4iLCJjcmVhdGVSb3ciLCJvcmlnaW5hbCIsInJvd0luZGV4Iiwic3ViUm93cyIsInBhcmVudElkIiwiX3ZhbHVlc0NhY2hlIiwiX3VuaXF1ZVZhbHVlc0NhY2hlIiwiaGFzT3duUHJvcGVydHkiLCJnZXRDb2x1bW4iLCJnZXRVbmlxdWVWYWx1ZXMiLCJfcm93JGdldFZhbHVlIiwiZ2V0TGVhZlJvd3MiLCJnZXRQYXJlbnRSb3ciLCJnZXRSb3ciLCJnZXRQYXJlbnRSb3dzIiwicGFyZW50Um93cyIsImN1cnJlbnRSb3ciLCJwYXJlbnRSb3ciLCJnZXRBbGxDZWxscyIsImdldEFsbExlYWZDb2x1bW5zIiwiX2dldEFsbENlbGxzQnlDb2x1bW5JZCIsImFsbENlbGxzIiwicmVkdWNlIiwiYWNjIiwiaSIsIkNvbHVtbkZhY2V0aW5nIiwiX2dldEZhY2V0ZWRSb3dNb2RlbCIsImdldEZhY2V0ZWRSb3dNb2RlbCIsImdldFByZUZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJNYXAiLCJfZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJpbmNsdWRlc1N0cmluZyIsImZpbHRlclZhbHVlIiwiX2ZpbHRlclZhbHVlJHRvU3RyaW5nIiwic2VhcmNoIiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImF1dG9SZW1vdmUiLCJ0ZXN0RmFsc2V5IiwiaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUiLCJfcm93JGdldFZhbHVlMiIsImVxdWFsc1N0cmluZyIsIl9yb3ckZ2V0VmFsdWUzIiwiYXJySW5jbHVkZXMiLCJfcm93JGdldFZhbHVlNCIsImFyckluY2x1ZGVzQWxsIiwiX3JvdyRnZXRWYWx1ZTUiLCJhcnJJbmNsdWRlc1NvbWUiLCJfcm93JGdldFZhbHVlNiIsImVxdWFscyIsIndlYWtFcXVhbHMiLCJpbk51bWJlclJhbmdlIiwicm93VmFsdWUiLCJyZXNvbHZlRmlsdGVyVmFsdWUiLCJ1bnNhZmVNaW4iLCJ1bnNhZmVNYXgiLCJwYXJzZWRNaW4iLCJwYXJzZUZsb2F0IiwicGFyc2VkTWF4IiwiTnVtYmVyIiwiaXNOYU4iLCJJbmZpbml0eSIsInRlbXAiLCJmaWx0ZXJGbnMiLCJDb2x1bW5GaWx0ZXJpbmciLCJnZXREZWZhdWx0Q29sdW1uRGVmIiwiZmlsdGVyRm4iLCJnZXRJbml0aWFsU3RhdGUiLCJzdGF0ZSIsImNvbHVtbkZpbHRlcnMiLCJnZXREZWZhdWx0T3B0aW9ucyIsIm9uQ29sdW1uRmlsdGVyc0NoYW5nZSIsImZpbHRlckZyb21MZWFmUm93cyIsIm1heExlYWZSb3dGaWx0ZXJEZXB0aCIsImdldEF1dG9GaWx0ZXJGbiIsImZpcnN0Um93IiwiZ2V0Q29yZVJvd01vZGVsIiwiZmxhdFJvd3MiLCJ2YWx1ZSIsImdldEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiIsImdldENhbkZpbHRlciIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYSIsIl90YWJsZSRvcHRpb25zJGVuYWJsZSIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTIiLCJlbmFibGVDb2x1bW5GaWx0ZXIiLCJlbmFibGVDb2x1bW5GaWx0ZXJzIiwiZW5hYmxlRmlsdGVycyIsImdldElzRmlsdGVyZWQiLCJnZXRGaWx0ZXJJbmRleCIsImdldEZpbHRlclZhbHVlIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtMiIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTMiLCJmaW5kSW5kZXgiLCJzZXRGaWx0ZXJWYWx1ZSIsInNldENvbHVtbkZpbHRlcnMiLCJwcmV2aW91c0ZpbHRlciIsIm5ld0ZpbHRlciIsInNob3VsZEF1dG9SZW1vdmVGaWx0ZXIiLCJfb2xkJGZpbHRlciIsIm5ld0ZpbHRlck9iaiIsIl9vbGQkbWFwIiwiX3RhYmxlIiwiY29sdW1uRmlsdGVyc01ldGEiLCJ1cGRhdGVGbiIsIl9mdW5jdGlvbmFsVXBkYXRlIiwicmVzZXRDb2x1bW5GaWx0ZXJzIiwiZGVmYXVsdFN0YXRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRjIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSIsImluaXRpYWxTdGF0ZSIsImdldEZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmlsdGVyZWRSb3dNb2RlbCIsIm1hbnVhbEZpbHRlcmluZyIsInN1bSIsIl9sZWFmUm93cyIsImNoaWxkUm93cyIsIm5leHQiLCJuZXh0VmFsdWUiLCJleHRlbnQiLCJtZWFuIiwibGVhZlJvd3MiLCJjb3VudCIsIm1lZGlhbiIsInZhbHVlcyIsIm1pZCIsImZsb29yIiwibnVtcyIsInNvcnQiLCJhIiwiYiIsInVuaXF1ZSIsImZyb20iLCJTZXQiLCJ1bmlxdWVDb3VudCIsInNpemUiLCJfY29sdW1uSWQiLCJhZ2dyZWdhdGlvbkZucyIsIkNvbHVtbkdyb3VwaW5nIiwiYWdncmVnYXRlZENlbGwiLCJwcm9wcyIsIl90b1N0cmluZyIsIl9wcm9wcyRnZXRWYWx1ZSIsImFnZ3JlZ2F0aW9uRm4iLCJncm91cGluZyIsIm9uR3JvdXBpbmdDaGFuZ2UiLCJncm91cGVkQ29sdW1uTW9kZSIsInRvZ2dsZUdyb3VwaW5nIiwic2V0R3JvdXBpbmciLCJnZXRDYW5Hcm91cCIsImVuYWJsZUdyb3VwaW5nIiwiZ2V0R3JvdXBpbmdWYWx1ZSIsImdldElzR3JvdXBlZCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cCIsImdldEdyb3VwZWRJbmRleCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cDIiLCJpbmRleE9mIiwiZ2V0VG9nZ2xlR3JvdXBpbmdIYW5kbGVyIiwiY2FuR3JvdXAiLCJnZXRBdXRvQWdncmVnYXRpb25GbiIsIk9iamVjdCIsImNhbGwiLCJnZXRBZ2dyZWdhdGlvbkZuIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnMiIsInJlc2V0R3JvdXBpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJGciLCJnZXRQcmVHcm91cGVkUm93TW9kZWwiLCJnZXRHcm91cGVkUm93TW9kZWwiLCJfZ2V0R3JvdXBlZFJvd01vZGVsIiwibWFudWFsR3JvdXBpbmciLCJncm91cGluZ0NvbHVtbklkIiwiX2dyb3VwaW5nVmFsdWVzQ2FjaGUiLCJnZXRJc1BsYWNlaG9sZGVyIiwiZ2V0SXNBZ2dyZWdhdGVkIiwiX3JvdyRzdWJSb3dzIiwibm9uR3JvdXBpbmdDb2x1bW5zIiwiY29sIiwiZ3JvdXBpbmdDb2x1bW5zIiwiZyIsIkNvbHVtbk9yZGVyaW5nIiwiY29sdW1uT3JkZXIiLCJvbkNvbHVtbk9yZGVyQ2hhbmdlIiwiZ2V0SW5kZXgiLCJwb3NpdGlvbiIsIl9nZXRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRJc0ZpcnN0Q29sdW1uIiwiX2NvbHVtbnMkIiwiZ2V0SXNMYXN0Q29sdW1uIiwiX2NvbHVtbnMiLCJzZXRDb2x1bW5PcmRlciIsInJlc2V0Q29sdW1uT3JkZXIiLCJvcmRlcmVkQ29sdW1ucyIsImNvbHVtbk9yZGVyQ29weSIsImNvbHVtbnNDb3B5IiwidGFyZ2V0Q29sdW1uSWQiLCJzaGlmdCIsImZvdW5kSW5kZXgiLCJzcGxpY2UiLCJnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlIiwiQ29sdW1uUGlubmluZyIsIm9uQ29sdW1uUGlubmluZ0NoYW5nZSIsInBpbiIsImNvbHVtbklkcyIsInNldENvbHVtblBpbm5pbmciLCJfb2xkJGxlZnQzIiwiX29sZCRyaWdodDMiLCJfb2xkJGxlZnQiLCJfb2xkJHJpZ2h0IiwiX29sZCRsZWZ0MiIsIl9vbGQkcmlnaHQyIiwiZ2V0Q2FuUGluIiwiX2QkY29sdW1uRGVmJGVuYWJsZVBpIiwiZW5hYmxlUGlubmluZyIsImVuYWJsZUNvbHVtblBpbm5pbmciLCJnZXRJc1Bpbm5lZCIsImxlYWZDb2x1bW5JZHMiLCJpc0xlZnQiLCJpc1JpZ2h0IiwiZ2V0UGlubmVkSW5kZXgiLCJnZXRDZW50ZXJWaXNpYmxlQ2VsbHMiLCJfZ2V0QWxsVmlzaWJsZUNlbGxzIiwibGVmdEFuZFJpZ2h0IiwiZ2V0TGVmdFZpc2libGVDZWxscyIsImNlbGxzIiwiZ2V0UmlnaHRWaXNpYmxlQ2VsbHMiLCJyZXNldENvbHVtblBpbm5pbmciLCJnZXRJc1NvbWVDb2x1bW5zUGlubmVkIiwiX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvIiwicGlubmluZ1N0YXRlIiwiX3Bpbm5pbmdTdGF0ZSRsZWZ0IiwiX3Bpbm5pbmdTdGF0ZSRyaWdodCIsImdldExlZnRMZWFmQ29sdW1ucyIsImdldFJpZ2h0TGVhZkNvbHVtbnMiLCJnZXRDZW50ZXJMZWFmQ29sdW1ucyIsImRlZmF1bHRDb2x1bW5TaXppbmciLCJtaW5TaXplIiwibWF4U2l6ZSIsIk1BWF9TQUZFX0lOVEVHRVIiLCJnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlIiwic3RhcnRPZmZzZXQiLCJzdGFydFNpemUiLCJkZWx0YU9mZnNldCIsImRlbHRhUGVyY2VudGFnZSIsImlzUmVzaXppbmdDb2x1bW4iLCJjb2x1bW5TaXppbmdTdGFydCIsIkNvbHVtblNpemluZyIsImNvbHVtblNpemluZyIsImNvbHVtblNpemluZ0luZm8iLCJjb2x1bW5SZXNpemVNb2RlIiwiY29sdW1uUmVzaXplRGlyZWN0aW9uIiwib25Db2x1bW5TaXppbmdDaGFuZ2UiLCJvbkNvbHVtblNpemluZ0luZm9DaGFuZ2UiLCJnZXRTaXplIiwiX2NvbHVtbiRjb2x1bW5EZWYkbWluIiwiX2NvbHVtbiRjb2x1bW5EZWYkbWF4IiwiY29sdW1uU2l6ZSIsImdldFN0YXJ0Iiwic2xpY2UiLCJnZXRBZnRlciIsInJlc2V0U2l6ZSIsInNldENvbHVtblNpemluZyIsIl9yZWYyIiwiXyIsInJlc3QiLCJnZXRDYW5SZXNpemUiLCJlbmFibGVSZXNpemluZyIsImVuYWJsZUNvbHVtblJlc2l6aW5nIiwiZ2V0SXNSZXNpemluZyIsIl9oZWFkZXIkY29sdW1uJGdldFNpeiIsInByZXZTaWJsaW5nSGVhZGVyIiwiZ2V0UmVzaXplSGFuZGxlciIsIl9jb250ZXh0RG9jdW1lbnQiLCJjYW5SZXNpemUiLCJlIiwicGVyc2lzdCIsImlzVG91Y2hTdGFydEV2ZW50IiwidG91Y2hlcyIsImNsaWVudFgiLCJuZXdDb2x1bW5TaXppbmciLCJ1cGRhdGVPZmZzZXQiLCJldmVudFR5cGUiLCJjbGllbnRYUG9zIiwic2V0Q29sdW1uU2l6aW5nSW5mbyIsIl9vbGQkc3RhcnRPZmZzZXQiLCJfb2xkJHN0YXJ0U2l6ZSIsImRlbHRhRGlyZWN0aW9uIiwiX3JlZjMiLCJoZWFkZXJTaXplIiwib25Nb3ZlIiwib25FbmQiLCJjb250ZXh0RG9jdW1lbnQiLCJkb2N1bWVudCIsIm1vdXNlRXZlbnRzIiwibW92ZUhhbmRsZXIiLCJ1cEhhbmRsZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidG91Y2hFdmVudHMiLCJjYW5jZWxhYmxlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJfZSR0b3VjaGVzJCIsInBhc3NpdmVJZlN1cHBvcnRlZCIsInBhc3NpdmVFdmVudFN1cHBvcnRlZCIsInBhc3NpdmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVzZXRDb2x1bW5TaXppbmciLCJyZXNldEhlYWRlclNpemVJbmZvIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRjMiIsImdldFRvdGFsU2l6ZSIsIl90YWJsZSRnZXRIZWFkZXJHcm91cCIsIl90YWJsZSRnZXRIZWFkZXJHcm91cDIiLCJnZXRMZWZ0VG90YWxTaXplIiwiX3RhYmxlJGdldExlZnRIZWFkZXJHIiwiX3RhYmxlJGdldExlZnRIZWFkZXJHMiIsImdldENlbnRlclRvdGFsU2l6ZSIsIl90YWJsZSRnZXRDZW50ZXJIZWFkZSIsIl90YWJsZSRnZXRDZW50ZXJIZWFkZTIiLCJnZXRSaWdodFRvdGFsU2l6ZSIsIl90YWJsZSRnZXRSaWdodEhlYWRlciIsIl90YWJsZSRnZXRSaWdodEhlYWRlcjIiLCJwYXNzaXZlU3VwcG9ydGVkIiwic3VwcG9ydGVkIiwid2luZG93IiwiZXJyIiwidHlwZSIsIkNvbHVtblZpc2liaWxpdHkiLCJjb2x1bW5WaXNpYmlsaXR5Iiwib25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlIiwidG9nZ2xlVmlzaWJpbGl0eSIsImdldENhbkhpZGUiLCJzZXRDb2x1bW5WaXNpYmlsaXR5IiwiY2hpbGRDb2x1bW5zIiwiYyIsImVuYWJsZUhpZGluZyIsImdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyIiwidGFyZ2V0IiwiY2hlY2tlZCIsImdldFZpc2libGVDZWxscyIsIm1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCIsImdldENvbHVtbnMiLCJnZXRWaXNpYmxlRmxhdENvbHVtbnMiLCJnZXRBbGxGbGF0Q29sdW1ucyIsImdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucyIsImdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucyIsInJlc2V0Q29sdW1uVmlzaWJpbGl0eSIsInRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlIiwiX3ZhbHVlIiwiZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSIsIm9iaiIsImdldElzU29tZUNvbHVtbnNWaXNpYmxlIiwiZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyIiwiX3RhcmdldCIsIkdsb2JhbEZhY2V0aW5nIiwiX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCIsImdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCIsIl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzIiwiZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyIsIl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzIiwiZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyIsIkdsb2JhbEZpbHRlcmluZyIsImdsb2JhbEZpbHRlciIsIm9uR2xvYmFsRmlsdGVyQ2hhbmdlIiwiZ2xvYmFsRmlsdGVyRm4iLCJnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIiLCJfdGFibGUkZ2V0Q29yZVJvd01vZGUiLCJnZXRDYW5HbG9iYWxGaWx0ZXIiLCJfdGFibGUkb3B0aW9ucyRnZXRDb2wiLCJlbmFibGVHbG9iYWxGaWx0ZXIiLCJnZXRHbG9iYWxBdXRvRmlsdGVyRm4iLCJnZXRHbG9iYWxGaWx0ZXJGbiIsInNldEdsb2JhbEZpbHRlciIsInJlc2V0R2xvYmFsRmlsdGVyIiwiUm93RXhwYW5kaW5nIiwiZXhwYW5kZWQiLCJvbkV4cGFuZGVkQ2hhbmdlIiwicGFnaW5hdGVFeHBhbmRlZFJvd3MiLCJyZWdpc3RlcmVkIiwicXVldWVkIiwiX2F1dG9SZXNldEV4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkYXV0b1JlIiwiX3F1ZXVlIiwiYXV0b1Jlc2V0QWxsIiwiYXV0b1Jlc2V0RXhwYW5kZWQiLCJtYW51YWxFeHBhbmRpbmciLCJyZXNldEV4cGFuZGVkIiwic2V0RXhwYW5kZWQiLCJ0b2dnbGVBbGxSb3dzRXhwYW5kZWQiLCJnZXRJc0FsbFJvd3NFeHBhbmRlZCIsIl90YWJsZSRpbml0aWFsU3RhdGUkZSIsImdldENhblNvbWVSb3dzRXhwYW5kIiwiZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsIiwiZ2V0Q2FuRXhwYW5kIiwiZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciIsImdldElzU29tZVJvd3NFeHBhbmRlZCIsImtleXMiLCJnZXRSb3dNb2RlbCIsImdldElzRXhwYW5kZWQiLCJnZXRFeHBhbmRlZERlcHRoIiwicm93SWRzIiwicm93c0J5SWQiLCJzcGxpdElkIiwiZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCIsImdldFNvcnRlZFJvd01vZGVsIiwiZ2V0RXhwYW5kZWRSb3dNb2RlbCIsIl9nZXRFeHBhbmRlZFJvd01vZGVsIiwidG9nZ2xlRXhwYW5kZWQiLCJfZXhwYW5kZWQiLCJleGlzdHMiLCJvbGRFeHBhbmRlZCIsInJvd0lkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIiwiZ2V0SXNSb3dFeHBhbmRlZCIsIl90YWJsZSRvcHRpb25zJGdldFJvdyIsImdldFJvd0NhbkV4cGFuZCIsImVuYWJsZUV4cGFuZGluZyIsImdldElzQWxsUGFyZW50c0V4cGFuZGVkIiwiaXNGdWxseUV4cGFuZGVkIiwiZ2V0VG9nZ2xlRXhwYW5kZWRIYW5kbGVyIiwiY2FuRXhwYW5kIiwiZGVmYXVsdFBhZ2VJbmRleCIsImRlZmF1bHRQYWdlU2l6ZSIsImdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUiLCJwYWdlSW5kZXgiLCJwYWdlU2l6ZSIsIlJvd1BhZ2luYXRpb24iLCJwYWdpbmF0aW9uIiwib25QYWdpbmF0aW9uQ2hhbmdlIiwiX2F1dG9SZXNldFBhZ2VJbmRleCIsImF1dG9SZXNldFBhZ2VJbmRleCIsIm1hbnVhbFBhZ2luYXRpb24iLCJyZXNldFBhZ2VJbmRleCIsInNldFBhZ2luYXRpb24iLCJzYWZlVXBkYXRlciIsIm5ld1N0YXRlIiwicmVzZXRQYWdpbmF0aW9uIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwIiwic2V0UGFnZUluZGV4IiwibWF4UGFnZUluZGV4IiwicGFnZUNvdW50IiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiIsInJlc2V0UGFnZVNpemUiLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAzIiwiX3RhYmxlJGluaXRpYWxTdGF0ZTIiLCJzZXRQYWdlU2l6ZSIsInRvcFJvd0luZGV4Iiwic2V0UGFnZUNvdW50IiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvIiwibmV3UGFnZUNvdW50IiwiZ2V0UGFnZU9wdGlvbnMiLCJnZXRQYWdlQ291bnQiLCJwYWdlT3B0aW9ucyIsImZpbGwiLCJnZXRDYW5QcmV2aW91c1BhZ2UiLCJnZXRDYW5OZXh0UGFnZSIsInByZXZpb3VzUGFnZSIsIm5leHRQYWdlIiwiZmlyc3RQYWdlIiwibGFzdFBhZ2UiLCJnZXRQYWdpbmF0aW9uUm93TW9kZWwiLCJfZ2V0UGFnaW5hdGlvblJvd01vZGVsIiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiIsImNlaWwiLCJnZXRSb3dDb3VudCIsIl90YWJsZSRvcHRpb25zJHJvd0NvdSIsInJvd0NvdW50Iiwicm93cyIsImdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUiLCJ0b3AiLCJib3R0b20iLCJSb3dQaW5uaW5nIiwicm93UGlubmluZyIsIm9uUm93UGlubmluZ0NoYW5nZSIsImluY2x1ZGVMZWFmUm93cyIsImluY2x1ZGVQYXJlbnRSb3dzIiwibGVhZlJvd0lkcyIsInBhcmVudFJvd0lkcyIsInNldFJvd1Bpbm5pbmciLCJfb2xkJHRvcDMiLCJfb2xkJGJvdHRvbTMiLCJfb2xkJHRvcCIsIl9vbGQkYm90dG9tIiwiaGFzIiwiX29sZCR0b3AyIiwiX29sZCRib3R0b20yIiwiZW5hYmxlUm93UGlubmluZyIsImlzVG9wIiwiaXNCb3R0b20iLCJfcmVmNCIsIl92aXNpYmxlUGlubmVkUm93SWRzJCIsInZpc2libGVQaW5uZWRSb3dJZHMiLCJnZXRUb3BSb3dzIiwiZ2V0Qm90dG9tUm93cyIsIl9yZWY1IiwicmVzZXRSb3dQaW5uaW5nIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRyIiwiZ2V0SXNTb21lUm93c1Bpbm5lZCIsIl9waW5uaW5nU3RhdGUkdG9wIiwiX3Bpbm5pbmdTdGF0ZSRib3R0b20iLCJfZ2V0UGlubmVkUm93cyIsInZpc2libGVSb3dzIiwicGlubmVkUm93SWRzIiwiX3RhYmxlJG9wdGlvbnMka2VlcFBpIiwia2VlcFBpbm5lZFJvd3MiLCJhbGxSb3dzIiwidG9wUGlubmVkUm93SWRzIiwiYm90dG9tUGlubmVkUm93SWRzIiwiZ2V0Q2VudGVyUm93cyIsInRvcEFuZEJvdHRvbSIsIlJvd1NlbGVjdGlvbiIsInJvd1NlbGVjdGlvbiIsIm9uUm93U2VsZWN0aW9uQ2hhbmdlIiwiZW5hYmxlUm93U2VsZWN0aW9uIiwiZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24iLCJlbmFibGVTdWJSb3dTZWxlY3Rpb24iLCJzZXRSb3dTZWxlY3Rpb24iLCJyZXNldFJvd1NlbGVjdGlvbiIsInRvZ2dsZUFsbFJvd3NTZWxlY3RlZCIsImdldElzQWxsUm93c1NlbGVjdGVkIiwicHJlR3JvdXBlZEZsYXRSb3dzIiwiZ2V0Q2FuU2VsZWN0IiwidG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCIsInJlc29sdmVkVmFsdWUiLCJnZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJtdXRhdGVSb3dJc1NlbGVjdGVkIiwiZ2V0UHJlU2VsZWN0ZWRSb3dNb2RlbCIsImdldFNlbGVjdGVkUm93TW9kZWwiLCJyb3dNb2RlbCIsInNlbGVjdFJvd3NGbiIsImdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCIsImdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsIiwiaXNBbGxSb3dzU2VsZWN0ZWQiLCJwYWdpbmF0aW9uRmxhdFJvd3MiLCJpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJnZXRJc1NvbWVSb3dzU2VsZWN0ZWQiLCJfdGFibGUkZ2V0U3RhdGUkcm93U2UiLCJ0b3RhbFNlbGVjdGVkIiwiZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCIsImdldElzU2VsZWN0ZWQiLCJnZXRJc1NvbWVTZWxlY3RlZCIsImdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIiLCJnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciIsInRvZ2dsZVNlbGVjdGVkIiwiaXNTZWxlY3RlZCIsIl9vcHRzJHNlbGVjdENoaWxkcmVuIiwic2VsZWN0ZWRSb3dJZHMiLCJzZWxlY3RDaGlsZHJlbiIsImlzUm93U2VsZWN0ZWQiLCJpc1N1YlJvd1NlbGVjdGVkIiwiZ2V0SXNBbGxTdWJSb3dzU2VsZWN0ZWQiLCJnZXRDYW5TZWxlY3RTdWJSb3dzIiwiZ2V0Q2FuTXVsdGlTZWxlY3QiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUzIiwiZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyIiwiY2FuU2VsZWN0IiwiaW5jbHVkZUNoaWxkcmVuIiwibmV3U2VsZWN0ZWRGbGF0Um93cyIsIm5ld1NlbGVjdGVkUm93c0J5SWQiLCJyZWN1cnNlUm93cyIsIl9yb3ckc3ViUm93czIiLCJzZWxlY3Rpb24iLCJfc2VsZWN0aW9uJHJvdyRpZCIsIl9yb3ckc3ViUm93czMiLCJhbGxDaGlsZHJlblNlbGVjdGVkIiwic29tZVNlbGVjdGVkIiwic3ViUm93Iiwic3ViUm93Q2hpbGRyZW5TZWxlY3RlZCIsInJlU3BsaXRBbHBoYU51bWVyaWMiLCJhbHBoYW51bWVyaWMiLCJyb3dBIiwicm93QiIsImNvbXBhcmVBbHBoYW51bWVyaWMiLCJhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlIiwidGV4dCIsImNvbXBhcmVCYXNpYyIsInRleHRDYXNlU2Vuc2l0aXZlIiwiZGF0ZXRpbWUiLCJiYXNpYyIsImFTdHIiLCJiU3RyIiwiYWEiLCJiYiIsImFuIiwicGFyc2VJbnQiLCJibiIsImNvbWJvIiwic29ydGluZ0ZucyIsIlJvd1NvcnRpbmciLCJzb3J0aW5nIiwic29ydGluZ0ZuIiwic29ydFVuZGVmaW5lZCIsIm9uU29ydGluZ0NoYW5nZSIsImlzTXVsdGlTb3J0RXZlbnQiLCJzaGlmdEtleSIsImdldEF1dG9Tb3J0aW5nRm4iLCJmaXJzdFJvd3MiLCJpc1N0cmluZyIsImdldEF1dG9Tb3J0RGlyIiwiZ2V0U29ydGluZ0ZuIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluMiIsInRvZ2dsZVNvcnRpbmciLCJkZXNjIiwibXVsdGkiLCJuZXh0U29ydGluZ09yZGVyIiwiZ2V0TmV4dFNvcnRpbmdPcmRlciIsImhhc01hbnVhbFZhbHVlIiwic2V0U29ydGluZyIsImV4aXN0aW5nU29ydGluZyIsImV4aXN0aW5nSW5kZXgiLCJuZXdTb3J0aW5nIiwic29ydEFjdGlvbiIsIm5leHREZXNjIiwiZ2V0Q2FuTXVsdGlTb3J0IiwiX3RhYmxlJG9wdGlvbnMkbWF4TXVsIiwibWF4TXVsdGlTb3J0Q29sQ291bnQiLCJnZXRGaXJzdFNvcnREaXIiLCJfY29sdW1uJGNvbHVtbkRlZiRzb3IiLCJzb3J0RGVzY0ZpcnN0IiwiZmlyc3RTb3J0RGlyZWN0aW9uIiwiaXNTb3J0ZWQiLCJnZXRJc1NvcnRlZCIsImVuYWJsZVNvcnRpbmdSZW1vdmFsIiwiZW5hYmxlTXVsdGlSZW1vdmUiLCJnZXRDYW5Tb3J0IiwiZW5hYmxlU29ydGluZyIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYTIiLCJlbmFibGVNdWx0aVNvcnQiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkiLCJjb2x1bW5Tb3J0IiwiZ2V0U29ydEluZGV4IiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMiIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aTMiLCJjbGVhclNvcnRpbmciLCJnZXRUb2dnbGVTb3J0aW5nSGFuZGxlciIsImNhblNvcnQiLCJyZXNldFNvcnRpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJHMiLCJnZXRQcmVTb3J0ZWRSb3dNb2RlbCIsIl9nZXRTb3J0ZWRSb3dNb2RlbCIsIm1hbnVhbFNvcnRpbmciLCJidWlsdEluRmVhdHVyZXMiLCJfb3B0aW9ucyRfZmVhdHVyZXMiLCJfb3B0aW9ucyRpbml0aWFsU3RhdGUiLCJkZWJ1Z1RhYmxlIiwiZGVmYXVsdE9wdGlvbnMiLCJhc3NpZ24iLCJtZXJnZU9wdGlvbnMiLCJjb3JlSW5pdGlhbFN0YXRlIiwiX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IiwicXVldWVkVGltZW91dCIsImNvcmVJbnN0YW5jZSIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY2F0Y2giLCJlcnJvciIsInNldFRpbWVvdXQiLCJyZXNldCIsInNldE9wdGlvbnMiLCJuZXdPcHRpb25zIiwib25TdGF0ZUNoYW5nZSIsIl9nZXRSb3dJZCIsImdldFJvd0lkIiwiX2dldENvcmVSb3dNb2RlbCIsInNlYXJjaEFsbCIsIl9kZWZhdWx0Q29sdW1uIiwiX3Byb3BzJHJlbmRlclZhbHVlJHRvIiwiX3Byb3BzJHJlbmRlclZhbHVlIiwiX2dldENvbHVtbkRlZnMiLCJjb2x1bW5EZWZzIiwicmVjdXJzZUNvbHVtbnMiLCJncm91cGluZ0NvbHVtbkRlZiIsIl9nZXRBbGxGbGF0Q29sdW1uc0J5SWQiLCJmbGF0Q29sdW1ucyIsImRhdGEiLCJhY2Nlc3NSb3dzIiwib3JpZ2luYWxSb3dzIiwiZ2V0U3ViUm93cyIsIl9yb3ckb3JpZ2luYWxTdWJSb3dzIiwib3JpZ2luYWxTdWJSb3dzIiwiZXhwYW5kUm93cyIsImV4cGFuZGVkUm93cyIsImhhbmRsZVJvdyIsIl90YWJsZSRnZXRDb2x1bW4iLCJmYWNldGVkUm93TW9kZWwiLCJ1bmlxdWVWYWx1ZXMiLCJmbGF0Um93IiwiX2ZsYXRSb3ckZ2V0VW5pcXVlVmFsIiwiZmFjZXRlZE1pblZhbHVlIiwiZmFjZXRlZE1heFZhbHVlIiwiZmlsdGVyUm93cyIsImZpbHRlclJvd0ltcGwiLCJmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyIsImZpbHRlclJvd01vZGVsRnJvbVJvb3QiLCJyb3dzVG9GaWx0ZXIiLCJmaWx0ZXJSb3ciLCJfdGFibGUkb3B0aW9ucyRtYXhMZWEiLCJuZXdGaWx0ZXJlZEZsYXRSb3dzIiwibmV3RmlsdGVyZWRSb3dzQnlJZCIsInJlY3Vyc2VGaWx0ZXJSb3dzIiwibmV3Um93IiwiX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiIsInBhc3MiLCJwcmVSb3dNb2RlbCIsImZpbHRlcmFibGVJZHMiLCJmaWx0ZXJSb3dzSW1wbCIsImZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJqIiwiX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkIiwic2V0IiwiZ2V0IiwicmVzb2x2ZWRDb2x1bW5GaWx0ZXJzIiwicmVzb2x2ZWRHbG9iYWxGaWx0ZXJzIiwiX2ZpbHRlckZuJHJlc29sdmVGaWx0IiwiZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucyIsIl9nbG9iYWxGaWx0ZXJGbiRyZXNvbCIsImN1cnJlbnRDb2x1bW5GaWx0ZXIiLCJjdXJyZW50R2xvYmFsRmlsdGVyIiwiZmlsdGVyTWV0YSIsIl9fZ2xvYmFsX18iLCJleGlzdGluZ0dyb3VwaW5nIiwiZ3JvdXBlZEZsYXRSb3dzIiwiZ3JvdXBlZFJvd3NCeUlkIiwiZ3JvdXBVcFJlY3Vyc2l2ZWx5Iiwicm93R3JvdXBzTWFwIiwiZ3JvdXBCeSIsImFnZ3JlZ2F0ZWRHcm91cGVkUm93cyIsImVudHJpZXMiLCJncm91cGluZ1ZhbHVlIiwiZ3JvdXBlZFJvd3MiLCJfZ3JvdXBlZFJvd3MkMCRnZXRWYWwiLCJhZ2dyZWdhdGVGbiIsImdyb3VwTWFwIiwicmVzS2V5IiwicHJldmlvdXMiLCJwYWdlU3RhcnQiLCJwYWdlRW5kIiwicGFnaW5hdGVkUm93TW9kZWwiLCJzb3J0aW5nU3RhdGUiLCJzb3J0ZWRGbGF0Um93cyIsImF2YWlsYWJsZVNvcnRpbmciLCJjb2x1bW5JbmZvQnlJZCIsInNvcnRFbnRyeSIsImludmVydFNvcnRpbmciLCJzb3J0RGF0YSIsInNvcnRlZERhdGEiLCJfc29ydEVudHJ5JGRlc2MiLCJjb2x1bW5JbmZvIiwiaXNEZXNjIiwic29ydEludCIsImFWYWx1ZSIsImJWYWx1ZSIsImFVbmRlZmluZWQiLCJiVW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;